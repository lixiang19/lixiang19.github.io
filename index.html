<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>李向的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="李向的笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李向的笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李向的笔记">
  
    <link rel="alternate" href="/atom.xml" title="李向的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">李向的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-写博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/写博客/" class="article-date">
  <time datetime="2019-03-20T09:35:51.610Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/写博客/">写博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="博客要认真写"><a href="#博客要认真写" class="headerlink" title="博客要认真写"></a>博客要认真写</h1><p>遇到问题或者有些小灵感，先用笔记记下来。博客用来总结笔记。</p>
<p>一篇博客应该能有完整的阅读体验，也就是说围绕一篇博客应该有一个中心。叙述完整，读者（或未来的自己）单单只读一篇博客就能得到知识。所以不能像笔记那么随随便便。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/写博客/" data-id="cjtjsyyu60004q8un9rm9bcnn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原型与原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/22/原型与原型链/" class="article-date">
  <time datetime="2019-02-22T07:49:04.000Z" itemprop="datePublished">2019-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/22/原型与原型链/">原型链与继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h1><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>原型链，js里最重要的两条链之一。每个对象都链接到一个原型对象并且从中继承属性。本篇博客从最基本的写起，最终写到c最简单的几个实现继承的方法</p>
<h1 id="构造函数·原型·实例"><a href="#构造函数·原型·实例" class="headerlink" title="构造函数·原型·实例"></a>构造函数·原型·实例</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在js中创建对象的方法有哪几种？简单的来说：一·对象字面量，二·工厂模式，三·构造函数，四·Object.create。对象字面量和工厂模不再赘述。深入剖析一下构造函数。也就是说在用new创建对象的时候这背后到底发生了什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person (name,age,job) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">    this.job = job</span><br><span class="line">&#125;</span><br><span class="line">let person1 = new Person(&apos;li&apos;,&apos;18&apos;,&apos;coder&apos;)</span><br><span class="line">let person2 =new Person(&apos;zhao&apos;,&apos;18&apos;,&apos;Psychological consultant&apos;)</span><br><span class="line">console.log(person1.name);</span><br><span class="line">console.log(person2.job);</span><br><span class="line">// li</span><br><span class="line">// Psychological consultant</span><br></pre></td></tr></table></figure>
<p>什么是构造函数呢？也是一个普通函数，但是它生来就是为了结合new创建对象的，那就叫它构造函数。</p>
<p>在这个过程中，发生了四件事：</p>
<ol>
<li>创建了一个新对象</li>
<li>将构造函数的作用域赋给这个新对象（this也指向了这个对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新的对象 ·</li>
</ol>
<p>p1和p2分别保存着Person的一个不同的实例，这两个对象都有一个构造函数属性-constructor，该属性指向Person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.construtor == Person</span><br></pre></td></tr></table></figure>
<p>person1和person2都是构造函数Person的实例</p>
<p>实例的构造函数属性（constructor）指向构造函数</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>现在，在之前的基础上进一步加一个新的概念：原型。</p>
<p>我们创建的每个函数都有一个原型属性-prototype，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面例子理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。原型又分为显示原型prototype和隐式原型<code>__proto__</code>，这两者区别后面再写。知道原型这个概念后，再来看上文的构造函数的过程，应该这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.__proto__ = Person.prototype</span><br><span class="line">Person.call(obj)</span><br><span class="line">return obj</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个空对象obj</li>
<li>将这个空对象的 <strong>proto</strong>成员指向了构造函数对象的prototype成员对象。</li>
<li>将构造函数的作用域赋给新对象，因此Person函数中的this指向新对象obj，然后再调用Person函数。</li>
<li>返回新对象obj。</li>
</ol>
<p>现在用原型的方式来创建一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &apos;lixiang&apos;</span><br><span class="line">Person.prototype.age = &apos;18&apos;</span><br><span class="line">Person.prototype.job = &apos;coder&apos;</span><br><span class="line">let person1 = new Person()</span><br><span class="line"></span><br><span class="line">console.log(person1.name);</span><br><span class="line">// lixiang</span><br><span class="line">或者</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">   name:  &apos;Zaxlct&apos;,</span><br><span class="line">   age: 28,</span><br><span class="line">   job: &apos;Software Engineer&apos;,</span><br><span class="line">   sayName: function() &#123;</span><br><span class="line">     alert(this.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面对原型的解释，不必再构造函数中定义对象实例的信息，可以把这些信息直接添加到原型对象中。</p>
<h2 id="深入理解原型对象"><a href="#深入理解原型对象" class="headerlink" title="深入理解原型对象"></a>深入理解原型对象</h2><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype<br>属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor<br>（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，<br>Person.prototype. constructor 指向 Person。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor == Person</span><br></pre></td></tr></table></figure>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则<br>都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部<br>属性），指向构造函数的原型对象。ECMA-262第 5版中管这个指针叫[[Prototype]]。虽然在脚本中<br>没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性<br><strong>proto</strong>也就是前文所说的隐形原型；而在其他实现中，这个属性对脚本则是完全不可见的。<strong>不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间</strong>。</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fo3sqvn8nyj30jx07igm4.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以得到三个式子</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor == Person</span><br><span class="line">person1.__proto__ == Person.prototype</span><br><span class="line">person1.constructor == Person</span><br></pre></td></tr></table></figure>
<p>前面构造函数时的理解现在可以修改了。person1 和 person2.其实并没有constructor 这个属性，这是属性是属于Person的原型对象的。只是person1 和 person2和可以继承原型对象的constructor这个属性。person1与Person2这两个实例其实与构造函数Person并没有直接关系，person1与Person2是与Person的原型对象才有直接关系。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var person1 = new Person();</span><br></pre></td></tr></table></figure>
<p>通过new操作符调用的函数就是构造函数。由构造函数构造的对象其 <strong>proto</strong> 指向<strong>其构造函数的prototype属性所指向的对象</strong> 。每个函数都有一个prototype属性，其所指向的对象带有contructor属性，这一属性指向自身。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>前面讲原型时讲到原型分为显示原型和隐式原型，我不知道谁这么分的，但这个说法明显会让人产生误解，认为这两者是相似而又有所不同的同类。但是。[[Prototype]]）应该被叫做<strong>连接</strong> 在前面的例子中这个连接存在于实例与构造函数的原型对象之间。那思考一下，构造函数原型的连接也就是<code>Person.prototype.__proto__</code>是什么？<code>Object.__proto__</code> 是什么？<code>Object.prototype__proto__</code> 又是什么？</p>
<p>前面开篇说函数对象连接到Function.prototype意思就是所有函数对象的[[prototype]]都指向Function.Prototype。它是一个空函数。所以可以得出结论 <code>Person.__proto__ === Function.prototype</code>接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.__proto__ ===Object.prototype` 最终`Object.prototype.__proto__ === null</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; 在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。</span><br><span class="line">&gt; &gt; ——《JavaScript 高级程序设计》第三版 P116</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>知道了所有构造器（含内置及自定义）的<code>__proto__</code>都是<code>Function.prototype</code> 而且<code>Function.prototype.__proto__ === Object.prototype</code> 这说明这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
<p>通过上文可以看出，js里面的prototype是存在连接与继承的，咱们可以让原型对象等于另一个类型的实例，这就构成了原型链。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>在面向对象编程里，比如java。有有个很重要的概念就是类，类的机制又有实例化，继承和多态。</p>
<p><strong>类意味着拷贝。</strong> 当一个传统的类被实例化时，就发生了类的行为向实例中拷贝。当类被继承时，也发生父类的行为向子类的拷贝。</p>
<p>问题是js中有类吗？答案是没有。但是，类只是一种设计模式，在js中可以通过模仿实现类的功能，而在es6中更是加入了class一个像是类其实是语法糖的东西。</p>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = new Foo( &quot;a&quot; );</span><br><span class="line">var b = new Foo( &quot;b&quot; );</span><br><span class="line"></span><br><span class="line">a.myName(); // &quot;a&quot;</span><br><span class="line">b.myName(); // &quot;b&quot;参考上面的构造器函数，当一个对象实例化时并不是直接继承，而是通过构造器函数一个中间层产生对象。具体见上文。</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="继承的基本模式"><a href="#继承的基本模式" class="headerlink" title="继承的基本模式"></a>继承的基本模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123; </span><br><span class="line">    this.property = true; </span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123; </span><br><span class="line">    return this.property; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">function SubType()&#123; </span><br><span class="line">    this.subproperty = false; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">//继承了 SuperType </span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line"> </span><br><span class="line">SubType.prototype.getSubValue = function ()&#123; </span><br><span class="line">    return this.subproperty; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">var instance = new SubType(); </span><br><span class="line">alert(instance.getSuperValue());      //true</span><br></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fo3srq6e8fj30lu0f0jt3.jpg" alt="img">)</p>
<p>以上代码定义了两个类型：SuperType 和 SubType。每个类型分别有一个属性和一个方法。它们<br>的主要区别是 SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给<br>SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。</p>
<h4 id="伪类继承的实现"><a href="#伪类继承的实现" class="headerlink" title="伪类继承的实现"></a>伪类继承的实现</h4><p>前面讲了很多基础的原理，现在写一写继承的方法，继承的实现方法分类</p>
<p>一.借用构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1. </span><br><span class="line">       　　function Animal()&#123;</span><br><span class="line"></span><br><span class="line">       　　　　this.species = &quot;动物&quot;;</span><br><span class="line"></span><br><span class="line">       　　&#125;</span><br><span class="line">       　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">   　　　　this.name = name;</span><br><span class="line"></span><br><span class="line">   　　　　this.color = color;</span><br><span class="line"></span><br><span class="line">   　　&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       　　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">       　　　　Animal.apply(this, arguments);</span><br><span class="line"></span><br><span class="line">       　　　　this.name = name;</span><br><span class="line"></span><br><span class="line">       　　　　this.color = color;</span><br><span class="line"></span><br><span class="line">       　　&#125;</span><br><span class="line"></span><br><span class="line">       　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">       　　alert(cat1.species); // 动物</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       　　Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">       　　Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">       　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">       　　alert(cat1.species); // 动物</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       　　function Animal()&#123; &#125;</span><br><span class="line"></span><br><span class="line">       　　Animal.prototype.species = &quot;动物&quot;;</span><br><span class="line"></span><br><span class="line">       Cat.prototype = Animal.prototype;</span><br><span class="line"></span><br><span class="line">   　　Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">   　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">   　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure>
<p>很简单就不写解释了，构造函数和原型的组合，也就是上面原型链的基本模式的应用。这种方法被js精粹称为伪类并且极为抨击：没有私有环境，所有的属性都是公开的，无法访问父类的方法，容易出错。</p>
<h3 id="es6继承的实现"><a href="#es6继承的实现" class="headerlink" title="es6继承的实现"></a>es6继承的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。</p>
</li>
<li><p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
</li>
<li>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加</li>
<li>只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错</li>
</ol>
<h1 id="抛开类"><a href="#抛开类" class="headerlink" title="抛开类"></a>抛开类</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>这个关键词是最误导人的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Foo();</span><br></pre></td></tr></table></figure>
<p>看到这个代码，想到的是什么，foo是构造函数？foo是个类？new将它实例化了？</p>
<p>但是都不对，foo仅仅是个函数，对象。一个普通的函数。</p>
<p>而new劫持了这个普通的函数并且调用了它，构造了一个对象并且赋值到a，这个调用被称为构造器调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = new Foo( &quot;a&quot; );</span><br><span class="line">var b = new Foo( &quot;b&quot; );</span><br><span class="line"></span><br><span class="line">a.myName(); // &quot;a&quot;</span><br><span class="line">b.myName(); // &quot;b&quot;</span><br></pre></td></tr></table></figure>
<p>上述代码如果按类的角度来解读：定义了类foo它有个方法myname，实例化foo得到实例a和实例b，实例a调用自身的从类继承来的方法myname输出a。</p>
<p>乍一看这个解释毫无问题，但是在js中，myname方法并没有拷贝到a上而是按照原型链查找向上查询取得的。</p>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>现在抛开类，js中只有对象，不管继承还是实例化都是对象和对象之间的关系，而每个对象都有一个原型。</p>
<p>官方标准，Object有个方法<code>Object.create</code>。</p>
<p><strong>Object.create()</strong> 方法会使用指定的原型对象及其属性去创建一个新的对象。也就是创建个新对象并且这个新对象内部的[[prototype]]链接到指定的对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Bar(name,label) &#123;</span><br><span class="line">	Foo.call( this, name );</span><br><span class="line">	this.label = label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里，我们创建一个新的`Bar.prototype`链接链到`Foo.prototype`</span><br><span class="line">Bar.prototype = Object.create( Foo.prototype );</span><br><span class="line"></span><br><span class="line">// 注意！现在`Bar.prototype.constructor`不存在了，</span><br><span class="line">// 如果你有依赖这个属性的习惯的话，可以被手动“修复”。</span><br><span class="line"></span><br><span class="line">Bar.prototype.myLabel = function() &#123;</span><br><span class="line">	return this.label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let a = new Bar( &quot;a&quot;, &quot;obj a&quot; );</span><br><span class="line"></span><br><span class="line">a.myName(); // &quot;a&quot;</span><br><span class="line">a.myLabel(); // &quot;obj a&quot;</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>js本身基于原型的原因，机制和类不一样。关注点应该在于链接。正确的在两个对象之间创建链接。而Object.create在使用的时候不需要考虑原型，构造函数也没new，仅仅是创立了链接。这样就够了。</p>
<h1 id="委托设计模式"><a href="#委托设计模式" class="headerlink" title="委托设计模式"></a>委托设计模式</h1><p>现在抛弃类，使用个新的设计模式。</p>
<p>当一个属性/方法引用在第一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，<code>[[Prototype]]</code>链接告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的<code>[[Prototype]]</code>查询，如此继续。这种对象间一系列的链接构成了所谓的“原形链”。</p>
<p>换句话说，对于我们能在JavaScript中利用的功能的实际机制来说，其重要的实质 <strong>全部在于被连接到其他对象的对象。</strong></p>
<p>一种思维模型。</p>
<p>抄的代码</p>
<p>问题：一个父类（也许称为<code>Wedget</code>）拥有所有共通的基本部件行为，然后衍生的子类拥有具体的部件类型（比如<code>Button</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Widget(width,height) &#123;</span><br><span class="line">	this.width = width || 50;</span><br><span class="line">	this.height = height || 50;</span><br><span class="line">	this.$elem = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget.prototype.render = function($where)&#123;</span><br><span class="line">	if (this.$elem) &#123;</span><br><span class="line">		this.$elem.css( &#123;</span><br><span class="line">			width: this.width + &quot;px&quot;,</span><br><span class="line">			height: this.height + &quot;px&quot;</span><br><span class="line">		&#125; ).appendTo( $where );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Button(width,height,label) &#123;</span><br><span class="line">	// &quot;super&quot;构造器调用</span><br><span class="line">	Widget.call( this, width, height );</span><br><span class="line">	this.label = label || &quot;Default&quot;;</span><br><span class="line"></span><br><span class="line">	this.$elem = $( &quot;&lt;button&gt;&quot; ).text( this.label );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使`Button` “继承” `Widget`</span><br><span class="line">Button.prototype = Object.create( Widget.prototype );</span><br><span class="line"></span><br><span class="line">// 覆盖“继承来的” `render(..)`</span><br><span class="line">Button.prototype.render = function($where) &#123;</span><br><span class="line">	// &quot;super&quot;调用</span><br><span class="line">	Widget.prototype.render.call( this, $where );</span><br><span class="line">	this.$elem.click( this.onClick.bind( this ) );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Button.prototype.onClick = function(evt) &#123;</span><br><span class="line">	console.log( &quot;Button &apos;&quot; + this.label + &quot;&apos; clicked!&quot; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$( document ).ready( function()&#123;</span><br><span class="line">	var $body = $( document.body );</span><br><span class="line">	var btn1 = new Button( 125, 30, &quot;Hello&quot; );</span><br><span class="line">	var btn2 = new Button( 150, 40, &quot;World&quot; );</span><br><span class="line"></span><br><span class="line">	btn1.render( $body );</span><br><span class="line">	btn2.render( $body );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>现在用上es6的class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">	constructor(width,height) &#123;</span><br><span class="line">		this.width = width || 50;</span><br><span class="line">		this.height = height || 50;</span><br><span class="line">		this.$elem = null;</span><br><span class="line">	&#125;</span><br><span class="line">	render($where)&#123;</span><br><span class="line">		if (this.$elem) &#123;</span><br><span class="line">			this.$elem.css( &#123;</span><br><span class="line">				width: this.width + &quot;px&quot;,</span><br><span class="line">				height: this.height + &quot;px&quot;</span><br><span class="line">			&#125; ).appendTo( $where );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Widget &#123;</span><br><span class="line">	constructor(width,height,label) &#123;</span><br><span class="line">		super( width, height );</span><br><span class="line">		this.label = label || &quot;Default&quot;;</span><br><span class="line">		this.$elem = $( &quot;&lt;button&gt;&quot; ).text( this.label );</span><br><span class="line">	&#125;</span><br><span class="line">	render($where) &#123;</span><br><span class="line">		super.render( $where );</span><br><span class="line">		this.$elem.click( this.onClick.bind( this ) );</span><br><span class="line">	&#125;</span><br><span class="line">	onClick(evt) &#123;</span><br><span class="line">		console.log( &quot;Button &apos;&quot; + this.label + &quot;&apos; clicked!&quot; );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$( document ).ready( function()&#123;</span><br><span class="line">	var $body = $( document.body );</span><br><span class="line">	var btn1 = new Button( 125, 30, &quot;Hello&quot; );</span><br><span class="line">	var btn2 = new Button( 150, 40, &quot;World&quot; );</span><br><span class="line"></span><br><span class="line">	btn1.render( $body );</span><br><span class="line">	btn2.render( $body );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>现在用行为委托</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">var Widget = &#123;</span><br><span class="line">	init: function(width,height)&#123;</span><br><span class="line">		this.width = width || 50;</span><br><span class="line">		this.height = height || 50;</span><br><span class="line">		this.$elem = null;</span><br><span class="line">	&#125;,</span><br><span class="line">	insert: function($where)&#123;</span><br><span class="line">		if (this.$elem) &#123;</span><br><span class="line">			this.$elem.css( &#123;</span><br><span class="line">				width: this.width + &quot;px&quot;,</span><br><span class="line">				height: this.height + &quot;px&quot;</span><br><span class="line">			&#125; ).appendTo( $where );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Button = Object.create( Widget );</span><br><span class="line"></span><br><span class="line">Button.setup = function(width,height,label)&#123;</span><br><span class="line">	// delegated call</span><br><span class="line">	this.init( width, height );</span><br><span class="line">	this.label = label || &quot;Default&quot;;</span><br><span class="line"></span><br><span class="line">	this.$elem = $( &quot;&lt;button&gt;&quot; ).text( this.label );</span><br><span class="line">&#125;;</span><br><span class="line">Button.build = function($where) &#123;</span><br><span class="line">	// delegated call</span><br><span class="line">	this.insert( $where );</span><br><span class="line">	this.$elem.click( this.onClick.bind( this ) );</span><br><span class="line">&#125;;</span><br><span class="line">Button.onClick = function(evt) &#123;</span><br><span class="line">	console.log( &quot;Button &apos;&quot; + this.label + &quot;&apos; clicked!&quot; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$( document ).ready( function()&#123;</span><br><span class="line">	var $body = $( document.body );</span><br><span class="line"></span><br><span class="line">	var btn1 = Object.create( Button );</span><br><span class="line">	btn1.setup( 125, 30, &quot;Hello&quot; );</span><br><span class="line"></span><br><span class="line">	var btn2 = Object.create( Button );</span><br><span class="line">	btn2.setup( 150, 40, &quot;World&quot; );</span><br><span class="line"></span><br><span class="line">	btn1.build( $body );</span><br><span class="line">	btn2.build( $body );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>不认为<code>Widget</code>是一个父类而<code>Button</code>是一个子类，<code>Wedget</code><strong>只是一个对象</strong> 和某种具体类型的部件也许想要代理到的工具的集合，而且<code>Button</code><strong>也只是一个独立的对象</strong></p>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>不管是什么方法在js中实现继承都是基于原型的。Object.create或者es6的class。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/22/原型与原型链/" data-id="cjtjsyyus000fq8unyt2r3pv8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-重温JS(1)-类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/22/重温JS(1)-类型/" class="article-date">
  <time datetime="2018-02-22T02:39:41.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/22/重温JS(1)-类型/">ss</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="重温JS-类型"><a href="#重温JS-类型" class="headerlink" title="重温JS-类型"></a>重温JS-类型</h1><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>七种数据数据类型，本篇博客主要讲数组和对象。</p>
<p>这篇博客不区分es6与js的差异。以es6为准。</p>
<p>js中变量没有类型而值有类型：基本数据类型值和引用类型值。<em>基本类型</em>就是简单的数据段。有五种：Undefined·Null·Boolean·Number·String。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p>
<p><em>引用类型</em>的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。有如下几种：Object·Array·Date·Regexp·Function·Boolean·Number·String。后面三种是为了便于操作基本类型值而提供的。</p>
<p>以上是《js高程》上的分类方法。但是如果直接写原始数据类型的话，有这七种：</p>
<ul>
<li><p><code>null</code></p>
</li>
<li><p><code>undefined</code></p>
</li>
<li><p><code>boolean</code></p>
</li>
<li><p><code>number</code></p>
</li>
<li><p><code>string</code></p>
</li>
<li><p><code>object</code></p>
</li>
<li><p><code>symbol</code> – 在ES6中被加入的！</p>
<p>很多子类型可以直接并入对象。</p>
</li>
</ul>
<h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><p>如果按照七种分法把数据类型分类就很好了。为什么还要按照《js高程》上面分的那么复杂呢。因为复制操作的不同。</p>
<h3 id="值与引用"><a href="#值与引用" class="headerlink" title="值与引用"></a>值与引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num1 = 5</span><br><span class="line">let num2 = num1</span><br></pre></td></tr></table></figure>
<p>在基本类型中变量复制另一个变量。复制后的结果是独立的。如下图</p>
<p><img src="assets/9GjmEq-1553222822386.png" alt="img"></p>
<p>这样导致的结果就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let a = 2</span><br><span class="line">let b = a</span><br><span class="line"></span><br><span class="line">console.log( &apos;修改前的b=&apos;+b );</span><br><span class="line">b = 3</span><br><span class="line">console.log(&apos;修改后的b=&apos;+b);</span><br><span class="line">console.log(&apos;修改后的a=&apos;+a);</span><br><span class="line">// 控制台结果</span><br><span class="line">修改前的b=2</span><br><span class="line"></span><br><span class="line">修改后的b=3</span><br><span class="line"></span><br><span class="line">修改后的a=2</span><br></pre></td></tr></table></figure>
<p>可以看到修改了b并不影响a。两者独立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = new Object()</span><br><span class="line">let obj2 = obj1</span><br><span class="line">obj1.name = &apos;snail&apos;</span><br><span class="line">alert(obj2.name)</span><br></pre></td></tr></table></figure>
<p>在引用类型中。复制操作结束后，两个变量实际上讲引用同一个对象。因此改变一个变量就会影响另一变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = new Object()</span><br><span class="line">let obj2 = obj1</span><br><span class="line">obj1.name = &apos;snail&apos;</span><br><span class="line">alert(obj2.name)</span><br><span class="line">obj2.name = &apos;fox&apos;</span><br><span class="line">alert(obj1.name)</span><br><span class="line">// </span><br><span class="line">snail</span><br><span class="line">fox</span><br></pre></td></tr></table></figure>
<p><img src="assets/9GjdPK-1553222822515.png" alt="img"></p>
<p>在此之上 ，函数的参数会有一个有关的问题。在函数篇讨论。</p>
<h1 id="值类型-1"><a href="#值类型-1" class="headerlink" title="值类型"></a>值类型</h1><p>在上面区分过复制操作后。下面的类型讲解就按照</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>object</code></li>
<li><code>symbol</code></li>
</ul>
<h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     === &quot;undefined&quot;; // true</span><br><span class="line">typeof true          === &quot;boolean&quot;;   // true</span><br><span class="line">typeof 42            === &quot;number&quot;;    // true</span><br><span class="line">typeof &quot;42&quot;          === &quot;string&quot;;    // true</span><br><span class="line">typeof &#123; life: 42 &#125;  === &quot;object&quot;;    // true</span><br><span class="line">typeof Symbol()      === &quot;symbol&quot;;    // true</span><br><span class="line">typeof null === &quot;object&quot;; </span><br><span class="line">// true</span><br><span class="line">typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;</span><br><span class="line">// true</span><br><span class="line">typeof function a()&#123; /* .. */ &#125; === &quot;Object&quot;</span><br><span class="line">// false</span><br><span class="line">typeof [1,2,3] === &quot;object&quot;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>如果要检测类型就用typeof。console.log一下在控制台中就可以看到结果。但是，<em>眼见不一定为实</em> 。</p>
<p>null不是对象，但是检测出来却是对象据说是个存在20年的bug不可能修复了。因为浏览器规范的原因，检测函数返回function这个倒是挺对的。但是却会让人误会函数是顶层的内建类型，其实函数是对象的子类型。同样的数组也是对象的子类型。</p>
<p>如果你想要使用<code>null</code>类型来测试<code>null</code>值，你需要一个复合条件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="判断类型的四种方法"><a href="#判断类型的四种方法" class="headerlink" title="判断类型的四种方法"></a>判断类型的四种方法</h2><ol>
<li><p>typeof<br>上面写了不可靠。</p>
</li>
<li><p>instanceof</p>
<p>instanceof用来判断A是否是B的实例。当 A 的 [[proto]] 指向 B 的 prototype 时,就会返回true</p>
</li>
</ol>
<p>​    因为这个方法的原理所有数组的判断结果对Object与Array都是true。<code>String和`</code>Date<code>对象同时也属于</code>Object<code>类型（他们是由</code>Object`类派生出来的）。所以它只能用来检测原型与构造函数不能用来检测类型</p>
<ol start="3">
<li><p>toString</p>
<p>这个常用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="string">''</span><span class="string">``</span>) ;  <span class="string">``</span><span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;   <span class="string">``</span><span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="literal">true</span><span class="string">``</span>) ;<span class="string">``</span><span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>());<span class="string">``</span><span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ;<span class="string">``</span><span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="literal">null</span><span class="string">``</span>) ;<span class="string">``</span><span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Function</span>()) ;<span class="string">``</span><span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Date</span>()) ;<span class="string">``</span><span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ;<span class="string">``</span><span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">RegExp</span>()) ;<span class="string">``</span><span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Error</span>()) ;<span class="string">``</span><span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ;<span class="string">``</span><span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ;<span class="string">``</span><span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="值类型-2"><a href="#值类型-2" class="headerlink" title="值类型"></a>值类型</h2><p>《you-dont-know-js》中把array·string·number称为值类型。《js高程》里讲Boolean·Number·String称为基本包装类型。这篇博客统称为值类型。因为不管叫什么怎么分，这些数据类型的目的就是为了操作值。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>在js中array只是值的容器。这些值可以是任何类型：<code>string</code>或者<code>number</code>或者<code>object</code>，甚至是另一个<code>array</code>（这也是你得到多维数组的方法）。数组的大小也是可以动态调整的。也就是随着数据的添加自动增长。真的是非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = [ ];</span><br><span class="line"></span><br><span class="line">a.length;	// 0</span><br><span class="line"></span><br><span class="line">a[0] = 1;</span><br><span class="line">a[1] = &quot;2&quot;;</span><br><span class="line">a[2] = [ 3 ];</span><br><span class="line"></span><br><span class="line">a.length;	// 3</span><br></pre></td></tr></table></figure>
<p>创建数组的方法有两种。</p>
<p>第一种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors = new Array(); </span><br><span class="line">let colors = Array(3);             // 创建一个包含 3 项的数组 </span><br><span class="line">let names = Array(&quot;Greg&quot;);   // 创建一个包含 1 项，即字符串&quot;Greg&quot;的数组</span><br><span class="line">Array.of(1) // [1]</span><br></pre></td></tr></table></figure>
<p>第二种 字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="数组的方法和属性"><a href="#数组的方法和属性" class="headerlink" title="数组的方法和属性"></a>数组的方法和属性</h3><h4 id="访问和长度"><a href="#访问和长度" class="headerlink" title="访问和长度"></a>访问和长度</h4><p>属性有length属性。以及继承的函数和对象的属性和方法，都暂略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">alert(colors[0]);   </span><br><span class="line">colors[colors.length] = &quot;black&quot;;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始下标为0，colors[0]。</li>
<li>有一个属性length，可以修改。</li>
<li>length不一定等于数组里的属性的个数。但是它一定等于这个数组的最大整数属性名加1。</li>
<li>数组最后一项的索引始终是 length-1</li>
<li>修改length后如果初始有5项，将length修改为3。过小。就会导致下标大于新length的属性被删除。</li>
<li>同理，想添加进最后一项也可以colors[colors.length] = “black”;</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>检测数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(value))&#123; </span><br><span class="line">    //对数组执行某些操作 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>扩展运算符</p>
<p>将一个数组转为用逗号分隔的参数序列。主要用于函数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) //这一行的...是rest参数。</span><br><span class="line">&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>增删操作</p>
<p>push()末尾增加·pop()末尾移除。</p>
<p>shift()头部移除·unshift头部增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">push返回的是修改后的长度</span><br><span class="line">pop返回的是移除的那一项</span><br><span class="line">shift返回的是移除的那一项</span><br><span class="line">unshift返回的是修改后的长度</span><br><span class="line">增加返回的都是长度，删除返回的是那一项。</span><br><span class="line"></span><br><span class="line">var colors = new Array();                  // 创建一个数组 </span><br><span class="line">var count = colors.push(&quot;red&quot;, &quot;green&quot;);   // 推入两项 </span><br><span class="line">alert(count);  //2 </span><br><span class="line"> </span><br><span class="line">count = colors.push(&quot;black&quot;);              // 推入另一项 </span><br><span class="line">alert(count);     //3 </span><br><span class="line"> </span><br><span class="line">var item = colors.pop();                  // 取得最后一项 </span><br><span class="line">alert(item);      //&quot;black&quot; </span><br><span class="line">alert(colors.length);   //2 </span><br><span class="line">var item = colors.shift();                  //取得第一项 </span><br><span class="line">alert(item);      //&quot;red&quot; </span><br><span class="line">alert(colors.length); //2 </span><br><span class="line">count = colors.unshift(&quot;black&quot;);                //推入另一项 </span><br><span class="line">alert(count);   //3</span><br></pre></td></tr></table></figure>
</li>
<li><p>重排序</p>
<p>reverse()反转数组项顺序</p>
<p>sort()升序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4, 5]; </span><br><span class="line">values.reverse(); </span><br><span class="line">alert(values);        //5,4,3,2,1 </span><br><span class="line">var values = [0, 1, 5, 10, 15]; </span><br><span class="line">values.sort(); </span><br><span class="line">alert(values);   //0,1,10,15,5 结果不理想</span><br><span class="line">//sort()也可以接受比较函数作为参数，修改为降序</span><br><span class="line">function compare(value1, value2) &#123; </span><br><span class="line">    if (value1 &lt; value2) &#123; </span><br><span class="line">        return 1; </span><br><span class="line">    &#125; else if (value1 &gt; value2) &#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        return 0; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var values = [0, 1, 5, 10, 15]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values);    // 15,10,5,1,0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>复制与合并</p>
<p>数组并不是基本类型值，如果直接=也只是复制了一个指针，如上面的代码一样会互相影响。所以复制操作不能简单的=。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//es5写法</span><br><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] = 2;//修改a2并不改变a1</span><br><span class="line">a1 // [1, 2]</span><br><span class="line">//es6写法</span><br><span class="line">const a1 = [1, 2];</span><br><span class="line">// 写法一</span><br><span class="line">const a2 = [...a1];</span><br><span class="line">// 写法二</span><br><span class="line">const [...a2] = a1;</span><br><span class="line"></span><br><span class="line">合并</span><br><span class="line">let arr1 = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">let arr2 = [&apos;c&apos;];</span><br><span class="line">let arr3 = [&apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// ES5的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br><span class="line"></span><br><span class="line">// ES6的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>splice</p>
<p>slice()的返回值是一个数组。接受三个参数。第一个为起始位置。第二个为删除的项数，第三个为插入的项。一个方法就可以实现可以实现增删改的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </span><br><span class="line">let removed = colors.splice(0,1);                // 删除第一项 </span><br><span class="line">alert(colors);     // green,blue </span><br><span class="line">alert(removed);    // red，返回的数组中只包含一项 </span><br><span class="line"> </span><br><span class="line">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);   // 从位置 1 开始插入两项 </span><br><span class="line">alert(colors);     // green,yellow,orange,blue </span><br><span class="line">alert(removed);    // 返回的是一个空数组 </span><br><span class="line"> </span><br><span class="line">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);      // 插入两项，删除一项 </span><br><span class="line">alert(colors);     // green,red,purple,orange,blue </span><br><span class="line">alert(removed);    // yellow，返回的数组中只包含一项</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p>转换</p>
<p>Array.from()用于将两类对象转化为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p>Array.of()用于将一组值转化为数组</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设设置一个数组长度为1，值为2.</span><br><span class="line">Array(2)的结果是一个长度为2的空数组。</span><br><span class="line">Array.of()则可以按目的显示。</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br><span class="line"></span><br><span class="line">Array.of(7);       // [7] </span><br><span class="line">Array.of(1, 2, 3); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">Array(7);          // [ , , , , , , ]</span><br><span class="line">Array(1, 2, 3);    // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>   join() 方法将一个数组（或一个<a href="https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects" target="_blank" rel="noopener">类数组对象</a>）的所有元素连接成一个字符串并返回这个字符串。</p>
<ol start="8">
<li><p>位置</p>
<p>indexOf()和 lastIndexOf()。这两个方法都接收<br>两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位<br>置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。</p>
<p>es6新增了find()返回值和findIndex()返回索引，都是接收一个测试函数作为第一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">alert(numbers.indexOf(4));        //3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line">function f(v)&#123;</span><br><span class="line">  return v &gt; this.age;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;name: &apos;John&apos;, age: 20&#125;;</span><br><span class="line">[10, 12, 26, 15].find(f, person);    // 26</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="9">
<li><p>迭代</p>
<p><strong>对数组进行操作</strong> 还是非常重要的。</p>
<p>ECMAScript 5为数组定义了 5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和<br>（可选的）运行该函数的作用域对象——影响 this 的值。</p>
</li>
</ol>
<p>    every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。<br>    filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。<br>    forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。<br>    map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>    some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">var filterResult = numbers.filter(function(item, index, array)&#123; </span><br><span class="line">    return (item &gt; 2); </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">alert(filterResult);  //[3,4,5,4,3] </span><br><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">var mapResult = numbers.map(function(item, index, array)&#123; </span><br><span class="line">    return item * 2; </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure>
<ol start="10">
<li><p>归并</p>
<p>reduce()和 reduceRight()。这两个方法都会迭<br>代数组的所有项，然后构建一个最终返回的值。可以做累加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5]; </span><br><span class="line">var sum = values.reduce(function(prev, cur, index, array)&#123; </span><br><span class="line">    return prev + cur;  </span><br><span class="line">&#125;); </span><br><span class="line">alert(sum); //15</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="11">
<li><p>fill</p>
<p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line">第二个和第三个参数用于指定填充的起始位置和结束位置</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</span><br><span class="line">// [&apos;a&apos;, 7, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法也是es6新增，知乎有个问题</p>
<p>JavaScript 怎么快速声明一个数组，长度为 100，元素全是 0？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(100), i=arr.length;</span><br><span class="line">while(i--)&#123;arr[i] = 0;&#125;</span><br><span class="line">或者</span><br><span class="line">Array.apply(null,Array(100)).map(function(item, i) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在es6里就只需要很短的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(100).fill(0)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>includes</p>
<p>返回一个布尔值，表示某个数组是否包含给定的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // true</span><br><span class="line">[1, 2, 3].includes(4)     // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多具体的方法和参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">点这里</a>。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串有两个特点：一·类似数组、二·不可变。</p>
<p>也就是说没办法原地修改内容的。</p>
<p>这里有两个方法，split讲一个string对象分隔成字符串数组，join将一个数组所有元素连接成字符串并返回这个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a =&apos;foo&apos;</span><br><span class="line">let c = a</span><br><span class="line">        .split(&apos;&apos;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">console.log(c)//oof</span><br></pre></td></tr></table></figure>
<p>借用数组的反转来反转字符串。</p>
<p>模板字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function authorize(user, action) &#123;</span><br><span class="line">  if (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    throw new Error(</span><br><span class="line">      // 传统写法为</span><br><span class="line">      // &apos;User &apos;</span><br><span class="line">      // + user.name</span><br><span class="line">      // + &apos; is not authorized to do &apos;</span><br><span class="line">      // + action</span><br><span class="line">      // + &apos;.&apos;</span><br><span class="line">      `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多api不赘述，看文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">点击这里</a>.<a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">es6新增点这里</a></p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>并没有分离出整数类型，1和1.0相同。就像java里的<strong>double</strong></p>
<p>有一个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3; // false</span><br><span class="line">0.30000000000000004</span><br><span class="line">在es6中新增了Number.EPSILON表示容差</span><br><span class="line">function numbersCloseEnoughToEqual(n1,n2) &#123;</span><br><span class="line">	return Math.abs( n1 - n2 ) &lt; Number.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 0.1 + 0.2;</span><br><span class="line">var b = 0.3;</span><br><span class="line"></span><br><span class="line">numbersCloseEnoughToEqual( a, b );					// true</span><br><span class="line">numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );	// false</span><br></pre></td></tr></table></figure>
<p>二进制浮点数的原因。</p>
<p>一些方法就不抄了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt" target="_blank" rel="noopener">点这里</a><a href="http://es6.ruanyifeng.com/#docs/number" target="_blank" rel="noopener">es6新增点这里</a></p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>如果操作本来要返回数值但是未返回数值的情况下，js中并不会抛出错误而是返回NaN。NaN不等于自身</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>对于<code>undefined</code>类型来说，有且仅有一个值：<code>undefined</code>。对于<code>null</code>类型来说，有且仅有一个值：<code>null</code>。所以对它们而言，这些文字既是它们的类型也是它们的值。</p>
<p>undefined翻译一下就是未定义。声明了一个变量但是没有初始化的时候，这个变量的值就是undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var message; </span><br><span class="line">alert(message == undefined); //true</span><br></pre></td></tr></table></figure>
<p>null值表示一个空对象指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var car = null; </span><br><span class="line">alert(typeof car);     // &quot;object&quot; </span><br><span class="line"> </span><br><span class="line">if (car != null)&#123; </span><br><span class="line">    // 对 car 对象执行某些操作 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会返回一个对象，前面说是一个bug。但就算是个bug也是有来由的。</p>
<blockquote>
<p>无论在什么情况下<br>都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，<br>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以<br>体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。</p>
</blockquote>
<p>null本来就是用于对象。bug也就bug了。</p>
<p>还有一点undefined是一个标识符。但是别用。所有不赘述。</p>
<p>Boolean</p>
<p>也就是true和false。区分大小写，可以用Boolean转换其他值为对应布尔值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var message = &quot;Hello world!&quot;; </span><br><span class="line">var messageAsBoolean = Boolean(message); </span><br><span class="line"> 跑一下</span><br><span class="line">  console.log(messageAsBoolean);</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转化为true</th>
<th>false</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>‘’(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数值</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>不适用</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>上表就是一些数据类型转化为布尔值的规则。还有一些其他问题在下一节类型转化讨论。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在js中 三种基本值<code>string</code>，<code>number</code>，或<code>boolean</code>可以发生类型转换 。可以分为隐含强制转换和明确强制转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 42;</span><br><span class="line"></span><br><span class="line">var b = a + &quot;&quot;;			// 隐含强制转换</span><br><span class="line"></span><br><span class="line">var c = String( a );	// 明确强制转换</span><br><span class="line">跑一下</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(c);</span><br><span class="line">// 结果42 42</span><br></pre></td></tr></table></figure>
<h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p>在布尔值一节有个表格，总结转换规则。现在把转换规则再总结</p>
<ul>
<li><p><code>undefined</code></p>
</li>
<li><p><code>null</code></p>
</li>
<li><p><code>false</code></p>
</li>
<li><p><code>+0</code>, <code>-0</code>, and <code>NaN</code></p>
</li>
<li><p><code>&quot;&quot;</code></p>
</li>
</ul>
<p>除去可以变为false的被称为falsy，其他全部变为true被称为truthy。</p>
<p><strong>如果一个值不在falsy列表中，它就是truthy</strong>。</p>
<p>这样就有一些代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if （function foo）&#123;</span><br><span class="line">	do something</span><br><span class="line">&#125;</span><br><span class="line">隐性的做了逻辑判断</span><br></pre></td></tr></table></figure>
<p>一些更复杂的细碎的例子<a href="https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md" target="_blank" rel="noopener">点这里</a></p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>js中出了基本值外，其他所有值都是对象。</p>
<p>对象是属性的容器，属性名总是字符串。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object(); </span><br><span class="line">person.name = &quot;Nicholas&quot;; </span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure>
<p>对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; </span><br><span class="line">    name : &quot;Nicholas&quot;, </span><br><span class="line">    age : 29 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="es6中对象的扩展"><a href="#es6中对象的扩展" class="headerlink" title="es6中对象的扩展"></a>es6中对象的扩展</h2><p>一些对象的基本知识不赘述。这里只总结Object在es6中的扩展</p>
<ol>
<li><p>简洁表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">属性和方法简写</span><br><span class="line">允许直接写入变量和函数，作为对象的属性和方法。方法也可以省个function。</span><br><span class="line">let birth = &apos;2000/01/01&apos;;</span><br><span class="line"></span><br><span class="line">const Person = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line"></span><br><span class="line">  //等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line"></span><br><span class="line">  // 等同于hello: function ()...</span><br><span class="line">  hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>属性名表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用对象字面量定义对象时，可以把表达式作为对象的属性名</span><br><span class="line">let propKey = &apos;foo&apos;;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [propKey]: true,</span><br><span class="line">  [&apos;a&apos; + &apos;bc&apos;]: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>方法的name属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数有name属性，对象的方法是函数所以也有name属性。</span><br><span class="line">const person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(&apos;hello!&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   // &quot;sayName&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>Object.is</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0</span><br><span class="line">它用来比较两个值是否严格相等</span><br><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>Object.assign</p>
<p>用于对象的合并。讲原对象的所有可枚举属性复制到目标对象，注意：浅拷贝·同名属性替换·取值函数会把值复制过去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>属性的可枚举和遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</span><br><span class="line">let obj = &#123; foo: 123 &#125;</span><br><span class="line">let a = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</span><br><span class="line">console.log(a);</span><br><span class="line">//configurable: true</span><br><span class="line">enumerable: true</span><br><span class="line">value: 123</span><br><span class="line">writable: true</span><br><span class="line"></span><br><span class="line">其中enumerable属性就是可枚举型</span><br></pre></td></tr></table></figure>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
</li>
<li><p>Object.getOwnPropertyDescriptor</p>
<p>一些高级用法，没用过就不复制粘贴了。以后用过再写。</p>
</li>
<li><p>[[Prototype]]的新增方法</p>
<p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let proto = &#123;&#125;;</span><br><span class="line">let obj = &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line"></span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br><span class="line">将proto对象设为了obj对象的原型。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf用于读取一个对象的原型对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>super关键字</p>
<p>super指向当前对象的原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const proto = &#123;</span><br><span class="line">  foo: &apos;hello&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() // &quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="10">
<li><p>Object.create</p>
<p>该方法会使用指定的原型对象及其属性去创建一个新的对象。该方法用于模仿继承。在原型篇详细些。</p>
</li>
</ol>
<h2 id="Date类型和RegExp类型"><a href="#Date类型和RegExp类型" class="headerlink" title="Date类型和RegExp类型"></a>Date类型和RegExp类型</h2><p>全是一些方法，写了也是复制粘贴一大串。</p>
<p>没什么特殊的地方<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">点这里看</a></p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是一种新机制可以保证每个属性的名字独一无二。</p>
<p>Symbol值通过Symbol函数生成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure>
<p>用作属性名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>如果想实现应用同样的Symbol值，可以使用Symbol.for(‘字符串值’),返回一个宜家登记的Symbol值。</p>
<h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>简单的说set类似于数组，但是成员的值都是唯一的，没有重复。<code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br><span class="line"></span><br><span class="line">// 例三</span><br><span class="line">const <span class="keyword">set</span> = new Set(document.querySelectorAll('div'));</span><br><span class="line"><span class="keyword">set</span>.size // 56</span><br><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br><span class="line">[...new Set('ababbc')].join('')</span><br><span class="line">// "abc"</span><br></pre></td></tr></table></figure>
<p>操作方法暂时不写，确实没怎么用过。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
<p>使用方法暂时不写，确实没怎么用过</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>js中的类型松散。基本类型不像其他语言分的那么细。而且还有隐含的强制转换。用的时候即方便又要倍加小心。引用类型就是Object对象的子类型。有个固有的属性和方法。而这些属性和方法是建立在原型上的。有关原型，拷贝，继承等等都不在这篇博客说了。本篇博客主要总结了一些内建类型的原生方法。以后随时增删。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/22/重温JS(1)-类型/" data-id="cjtjsyyux000jq8un7xxrgv69" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/20/写博客/">写博客</a>
          </li>
        
          <li>
            <a href="/2019/02/22/原型与原型链/">原型链与继承</a>
          </li>
        
          <li>
            <a href="/2018/02/22/重温JS(1)-类型/">ss</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 李向<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>