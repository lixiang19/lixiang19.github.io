<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>李向的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="李向的笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李向的笔记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李向的笔记">
  
    <link rel="alternate" href="/atom.xml" title="李向的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">李向的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-sa" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/sa/" class="article-date">
  <time datetime="2019-03-22T07:49:10.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/sa/">sa</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/sa/" data-id="cjtjs8kan0000fgun8q4q0z00" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ssss" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/ssss/" class="article-date">
  <time datetime="2019-03-22T07:48:59.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/ssss/">ssss</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/ssss/" data-id="cjtjs8kas0001fgun4en0hfh3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ss" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/ss/" class="article-date">
  <time datetime="2019-03-22T07:48:52.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/ss/">ss</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/ss/" data-id="cjtjs8kat0002fgune8t6y7bx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-写博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/写博客/" class="article-date">
  <time datetime="2019-03-20T09:35:51.610Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/写博客/">写博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="博客要认真写"><a href="#博客要认真写" class="headerlink" title="博客要认真写"></a>博客要认真写</h1><p>遇到问题或者有些小灵感，先用笔记记下来。博客用来总结笔记。</p>
<p>一篇博客应该能有完整的阅读体验，也就是说围绕一篇博客应该有一个中心。叙述完整，读者（或未来的自己）单单只读一篇博客就能得到知识。所以不能像笔记那么随随便便。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/写博客/" data-id="cjtjs8kau0003fgunekgy0q9b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-原型与原型链" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/22/原型与原型链/" class="article-date">
  <time datetime="2019-02-22T07:49:04.000Z" itemprop="datePublished">2019-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/22/原型与原型链/">原型链与继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h1><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>原型链，js里最重要的两条链之一。每个对象都链接到一个原型对象并且从中继承属性。本篇博客从最基本的写起，最终写到c最简单的几个实现继承的方法</p>
<h1 id="构造函数·原型·实例"><a href="#构造函数·原型·实例" class="headerlink" title="构造函数·原型·实例"></a>构造函数·原型·实例</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>在js中创建对象的方法有哪几种？简单的来说：一·对象字面量，二·工厂模式，三·构造函数，四·Object.create。对象字面量和工厂模不再赘述。深入剖析一下构造函数。也就是说在用new创建对象的时候这背后到底发生了什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person (name,age,job) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">    this.job = job</span><br><span class="line">&#125;</span><br><span class="line">let person1 = new Person(&apos;li&apos;,&apos;18&apos;,&apos;coder&apos;)</span><br><span class="line">let person2 =new Person(&apos;zhao&apos;,&apos;18&apos;,&apos;Psychological consultant&apos;)</span><br><span class="line">console.log(person1.name);</span><br><span class="line">console.log(person2.job);</span><br><span class="line">// li</span><br><span class="line">// Psychological consultant</span><br></pre></td></tr></table></figure>
<p>什么是构造函数呢？也是一个普通函数，但是它生来就是为了结合new创建对象的，那就叫它构造函数。</p>
<p>在这个过程中，发生了四件事：</p>
<ol>
<li>创建了一个新对象</li>
<li>将构造函数的作用域赋给这个新对象（this也指向了这个对象）</li>
<li>执行构造函数中的代码（为这个新对象添加属性）</li>
<li>返回新的对象 ·</li>
</ol>
<p>p1和p2分别保存着Person的一个不同的实例，这两个对象都有一个构造函数属性-constructor，该属性指向Person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person1.construtor == Person</span><br></pre></td></tr></table></figure>
<p>person1和person2都是构造函数Person的实例</p>
<p>实例的构造函数属性（constructor）指向构造函数</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>现在，在之前的基础上进一步加一个新的概念：原型。</p>
<p>我们创建的每个函数都有一个原型属性-prototype，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。按字面例子理解，prototype就是通过调用构造函数而创建的那个对象实例的原型对象。原型又分为显示原型prototype和隐式原型<code>__proto__</code>，这两者区别后面再写。知道原型这个概念后，再来看上文的构造函数的过程，应该这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.__proto__ = Person.prototype</span><br><span class="line">Person.call(obj)</span><br><span class="line">return obj</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个空对象obj</li>
<li>将这个空对象的 <strong>proto</strong>成员指向了构造函数对象的prototype成员对象。</li>
<li>将构造函数的作用域赋给新对象，因此Person函数中的this指向新对象obj，然后再调用Person函数。</li>
<li>返回新对象obj。</li>
</ol>
<p>现在用原型的方式来创建一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person () &#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = &apos;lixiang&apos;</span><br><span class="line">Person.prototype.age = &apos;18&apos;</span><br><span class="line">Person.prototype.job = &apos;coder&apos;</span><br><span class="line">let person1 = new Person()</span><br><span class="line"></span><br><span class="line">console.log(person1.name);</span><br><span class="line">// lixiang</span><br><span class="line">或者</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">   name:  &apos;Zaxlct&apos;,</span><br><span class="line">   age: 28,</span><br><span class="line">   job: &apos;Software Engineer&apos;,</span><br><span class="line">   sayName: function() &#123;</span><br><span class="line">     alert(this.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据前面对原型的解释，不必再构造函数中定义对象实例的信息，可以把这些信息直接添加到原型对象中。</p>
<h2 id="深入理解原型对象"><a href="#深入理解原型对象" class="headerlink" title="深入理解原型对象"></a>深入理解原型对象</h2><p>无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype<br>属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor<br>（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，<br>Person.prototype. constructor 指向 Person。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor == Person</span><br></pre></td></tr></table></figure>
<p>创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则<br>都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部<br>属性），指向构造函数的原型对象。ECMA-262第 5版中管这个指针叫[[Prototype]]。虽然在脚本中<br>没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性<br><strong>proto</strong>也就是前文所说的隐形原型；而在其他实现中，这个属性对脚本则是完全不可见的。<strong>不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间</strong>。</p>
<p><img src="http://ww1.sinaimg.cn/large/0060lm7Tly1fo3sqvn8nyj30jx07igm4.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以得到三个式子</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor == Person</span><br><span class="line">person1.__proto__ == Person.prototype</span><br><span class="line">person1.constructor == Person</span><br></pre></td></tr></table></figure>
<p>前面构造函数时的理解现在可以修改了。person1 和 person2.其实并没有constructor 这个属性，这是属性是属于Person的原型对象的。只是person1 和 person2和可以继承原型对象的constructor这个属性。person1与Person2这两个实例其实与构造函数Person并没有直接关系，person1与Person2是与Person的原型对象才有直接关系。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;</span><br><span class="line">var person1 = new Person();</span><br></pre></td></tr></table></figure>
<p>通过new操作符调用的函数就是构造函数。由构造函数构造的对象其 <strong>proto</strong> 指向<strong>其构造函数的prototype属性所指向的对象</strong> 。每个函数都有一个prototype属性，其所指向的对象带有contructor属性，这一属性指向自身。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>前面讲原型时讲到原型分为显示原型和隐式原型，我不知道谁这么分的，但这个说法明显会让人产生误解，认为这两者是相似而又有所不同的同类。但是。[[Prototype]]）应该被叫做<strong>连接</strong> 在前面的例子中这个连接存在于实例与构造函数的原型对象之间。那思考一下，构造函数原型的连接也就是<code>Person.prototype.__proto__</code>是什么？<code>Object.__proto__</code> 是什么？<code>Object.prototype__proto__</code> 又是什么？</p>
<p>前面开篇说函数对象连接到Function.prototype意思就是所有函数对象的[[prototype]]都指向Function.Prototype。它是一个空函数。所以可以得出结论 <code>Person.__proto__ === Function.prototype</code>接着</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.__proto__ ===Object.prototype` 最终`Object.prototype.__proto__ === null</span><br></pre></td></tr></table></figure>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt; 在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。</span><br><span class="line">&gt; &gt; ——《JavaScript 高级程序设计》第三版 P116</span><br><span class="line">&gt; &gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>知道了所有构造器（含内置及自定义）的<code>__proto__</code>都是<code>Function.prototype</code> 而且<code>Function.prototype.__proto__ === Object.prototype</code> 这说明这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。</p>
<p>通过上文可以看出，js里面的prototype是存在连接与继承的，咱们可以让原型对象等于另一个类型的实例，这就构成了原型链。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>在面向对象编程里，比如java。有有个很重要的概念就是类，类的机制又有实例化，继承和多态。</p>
<p><strong>类意味着拷贝。</strong> 当一个传统的类被实例化时，就发生了类的行为向实例中拷贝。当类被继承时，也发生父类的行为向子类的拷贝。</p>
<p>问题是js中有类吗？答案是没有。但是，类只是一种设计模式，在js中可以通过模仿实现类的功能，而在es6中更是加入了class一个像是类其实是语法糖的东西。</p>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = new Foo( &quot;a&quot; );</span><br><span class="line">var b = new Foo( &quot;b&quot; );</span><br><span class="line"></span><br><span class="line">a.myName(); // &quot;a&quot;</span><br><span class="line">b.myName(); // &quot;b&quot;参考上面的构造器函数，当一个对象实例化时并不是直接继承，而是通过构造器函数一个中间层产生对象。具体见上文。</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="继承的基本模式"><a href="#继承的基本模式" class="headerlink" title="继承的基本模式"></a>继承的基本模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function SuperType()&#123; </span><br><span class="line">    this.property = true; </span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.getSuperValue = function()&#123; </span><br><span class="line">    return this.property; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">function SubType()&#123; </span><br><span class="line">    this.subproperty = false; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">//继承了 SuperType </span><br><span class="line">SubType.prototype = new SuperType(); </span><br><span class="line"> </span><br><span class="line">SubType.prototype.getSubValue = function ()&#123; </span><br><span class="line">    return this.subproperty; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">var instance = new SubType(); </span><br><span class="line">alert(instance.getSuperValue());      //true</span><br></pre></td></tr></table></figure>
<p><img src="http://ww3.sinaimg.cn/large/0060lm7Tly1fo3srq6e8fj30lu0f0jt3.jpg" alt="img">)</p>
<p>以上代码定义了两个类型：SuperType 和 SubType。每个类型分别有一个属性和一个方法。它们<br>的主要区别是 SubType 继承了 SuperType，而继承是通过创建 SuperType 的实例，并将该实例赋给<br>SubType.prototype 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。</p>
<h4 id="伪类继承的实现"><a href="#伪类继承的实现" class="headerlink" title="伪类继承的实现"></a>伪类继承的实现</h4><p>前面讲了很多基础的原理，现在写一写继承的方法，继承的实现方法分类</p>
<p>一.借用构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1. </span><br><span class="line">       　　function Animal()&#123;</span><br><span class="line"></span><br><span class="line">       　　　　this.species = &quot;动物&quot;;</span><br><span class="line"></span><br><span class="line">       　　&#125;</span><br><span class="line">       　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">   　　　　this.name = name;</span><br><span class="line"></span><br><span class="line">   　　　　this.color = color;</span><br><span class="line"></span><br><span class="line">   　　&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       　　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">       　　　　Animal.apply(this, arguments);</span><br><span class="line"></span><br><span class="line">       　　　　this.name = name;</span><br><span class="line"></span><br><span class="line">       　　　　this.color = color;</span><br><span class="line"></span><br><span class="line">       　　&#125;</span><br><span class="line"></span><br><span class="line">       　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">       　　alert(cat1.species); // 动物</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       　　Cat.prototype = new Animal();</span><br><span class="line"></span><br><span class="line">       　　Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">       　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">       　　alert(cat1.species); // 动物</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       　　function Animal()&#123; &#125;</span><br><span class="line"></span><br><span class="line">       　　Animal.prototype.species = &quot;动物&quot;;</span><br><span class="line"></span><br><span class="line">       Cat.prototype = Animal.prototype;</span><br><span class="line"></span><br><span class="line">   　　Cat.prototype.constructor = Cat;</span><br><span class="line"></span><br><span class="line">   　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">   　　alert(cat1.species); // 动物</span><br></pre></td></tr></table></figure>
<p>很简单就不写解释了，构造函数和原型的组合，也就是上面原型链的基本模式的应用。这种方法被js精粹称为伪类并且极为抨击：没有私有环境，所有的属性都是公开的，无法访问父类的方法，容易出错。</p>
<h3 id="es6继承的实现"><a href="#es6继承的实现" class="headerlink" title="es6继承的实现"></a>es6继承的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。</p>
</li>
<li><p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p>
</li>
<li>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加</li>
<li>只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错</li>
</ol>
<h1 id="抛开类"><a href="#抛开类" class="headerlink" title="抛开类"></a>抛开类</h1><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p>这个关键词是最误导人的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Foo();</span><br></pre></td></tr></table></figure>
<p>看到这个代码，想到的是什么，foo是构造函数？foo是个类？new将它实例化了？</p>
<p>但是都不对，foo仅仅是个函数，对象。一个普通的函数。</p>
<p>而new劫持了这个普通的函数并且调用了它，构造了一个对象并且赋值到a，这个调用被称为构造器调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a = new Foo( &quot;a&quot; );</span><br><span class="line">var b = new Foo( &quot;b&quot; );</span><br><span class="line"></span><br><span class="line">a.myName(); // &quot;a&quot;</span><br><span class="line">b.myName(); // &quot;b&quot;</span><br></pre></td></tr></table></figure>
<p>上述代码如果按类的角度来解读：定义了类foo它有个方法myname，实例化foo得到实例a和实例b，实例a调用自身的从类继承来的方法myname输出a。</p>
<p>乍一看这个解释毫无问题，但是在js中，myname方法并没有拷贝到a上而是按照原型链查找向上查询取得的。</p>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>现在抛开类，js中只有对象，不管继承还是实例化都是对象和对象之间的关系，而每个对象都有一个原型。</p>
<p>官方标准，Object有个方法<code>Object.create</code>。</p>
<p><strong>Object.create()</strong> 方法会使用指定的原型对象及其属性去创建一个新的对象。也就是创建个新对象并且这个新对象内部的[[prototype]]链接到指定的对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function Foo(name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.myName = function() &#123;</span><br><span class="line">	return this.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Bar(name,label) &#123;</span><br><span class="line">	Foo.call( this, name );</span><br><span class="line">	this.label = label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这里，我们创建一个新的`Bar.prototype`链接链到`Foo.prototype`</span><br><span class="line">Bar.prototype = Object.create( Foo.prototype );</span><br><span class="line"></span><br><span class="line">// 注意！现在`Bar.prototype.constructor`不存在了，</span><br><span class="line">// 如果你有依赖这个属性的习惯的话，可以被手动“修复”。</span><br><span class="line"></span><br><span class="line">Bar.prototype.myLabel = function() &#123;</span><br><span class="line">	return this.label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let a = new Bar( &quot;a&quot;, &quot;obj a&quot; );</span><br><span class="line"></span><br><span class="line">a.myName(); // &quot;a&quot;</span><br><span class="line">a.myLabel(); // &quot;obj a&quot;</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>js本身基于原型的原因，机制和类不一样。关注点应该在于链接。正确的在两个对象之间创建链接。而Object.create在使用的时候不需要考虑原型，构造函数也没new，仅仅是创立了链接。这样就够了。</p>
<h1 id="委托设计模式"><a href="#委托设计模式" class="headerlink" title="委托设计模式"></a>委托设计模式</h1><p>现在抛弃类，使用个新的设计模式。</p>
<p>当一个属性/方法引用在第一个对象上发生，而这样的属性/方法又不存在时，这个链接就会被使用。在这种情况下，<code>[[Prototype]]</code>链接告诉引擎去那个被链接的对象上寻找该属性/方法。接下来，如果那个对象也不能满足查询，就沿着它的<code>[[Prototype]]</code>查询，如此继续。这种对象间一系列的链接构成了所谓的“原形链”。</p>
<p>换句话说，对于我们能在JavaScript中利用的功能的实际机制来说，其重要的实质 <strong>全部在于被连接到其他对象的对象。</strong></p>
<p>一种思维模型。</p>
<p>抄的代码</p>
<p>问题：一个父类（也许称为<code>Wedget</code>）拥有所有共通的基本部件行为，然后衍生的子类拥有具体的部件类型（比如<code>Button</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Widget(width,height) &#123;</span><br><span class="line">	this.width = width || 50;</span><br><span class="line">	this.height = height || 50;</span><br><span class="line">	this.$elem = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget.prototype.render = function($where)&#123;</span><br><span class="line">	if (this.$elem) &#123;</span><br><span class="line">		this.$elem.css( &#123;</span><br><span class="line">			width: this.width + &quot;px&quot;,</span><br><span class="line">			height: this.height + &quot;px&quot;</span><br><span class="line">		&#125; ).appendTo( $where );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 子类</span><br><span class="line">function Button(width,height,label) &#123;</span><br><span class="line">	// &quot;super&quot;构造器调用</span><br><span class="line">	Widget.call( this, width, height );</span><br><span class="line">	this.label = label || &quot;Default&quot;;</span><br><span class="line"></span><br><span class="line">	this.$elem = $( &quot;&lt;button&gt;&quot; ).text( this.label );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使`Button` “继承” `Widget`</span><br><span class="line">Button.prototype = Object.create( Widget.prototype );</span><br><span class="line"></span><br><span class="line">// 覆盖“继承来的” `render(..)`</span><br><span class="line">Button.prototype.render = function($where) &#123;</span><br><span class="line">	// &quot;super&quot;调用</span><br><span class="line">	Widget.prototype.render.call( this, $where );</span><br><span class="line">	this.$elem.click( this.onClick.bind( this ) );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Button.prototype.onClick = function(evt) &#123;</span><br><span class="line">	console.log( &quot;Button &apos;&quot; + this.label + &quot;&apos; clicked!&quot; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$( document ).ready( function()&#123;</span><br><span class="line">	var $body = $( document.body );</span><br><span class="line">	var btn1 = new Button( 125, 30, &quot;Hello&quot; );</span><br><span class="line">	var btn2 = new Button( 150, 40, &quot;World&quot; );</span><br><span class="line"></span><br><span class="line">	btn1.render( $body );</span><br><span class="line">	btn2.render( $body );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>现在用上es6的class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">	constructor(width,height) &#123;</span><br><span class="line">		this.width = width || 50;</span><br><span class="line">		this.height = height || 50;</span><br><span class="line">		this.$elem = null;</span><br><span class="line">	&#125;</span><br><span class="line">	render($where)&#123;</span><br><span class="line">		if (this.$elem) &#123;</span><br><span class="line">			this.$elem.css( &#123;</span><br><span class="line">				width: this.width + &quot;px&quot;,</span><br><span class="line">				height: this.height + &quot;px&quot;</span><br><span class="line">			&#125; ).appendTo( $where );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Button extends Widget &#123;</span><br><span class="line">	constructor(width,height,label) &#123;</span><br><span class="line">		super( width, height );</span><br><span class="line">		this.label = label || &quot;Default&quot;;</span><br><span class="line">		this.$elem = $( &quot;&lt;button&gt;&quot; ).text( this.label );</span><br><span class="line">	&#125;</span><br><span class="line">	render($where) &#123;</span><br><span class="line">		super.render( $where );</span><br><span class="line">		this.$elem.click( this.onClick.bind( this ) );</span><br><span class="line">	&#125;</span><br><span class="line">	onClick(evt) &#123;</span><br><span class="line">		console.log( &quot;Button &apos;&quot; + this.label + &quot;&apos; clicked!&quot; );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$( document ).ready( function()&#123;</span><br><span class="line">	var $body = $( document.body );</span><br><span class="line">	var btn1 = new Button( 125, 30, &quot;Hello&quot; );</span><br><span class="line">	var btn2 = new Button( 150, 40, &quot;World&quot; );</span><br><span class="line"></span><br><span class="line">	btn1.render( $body );</span><br><span class="line">	btn2.render( $body );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>现在用行为委托</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">var Widget = &#123;</span><br><span class="line">	init: function(width,height)&#123;</span><br><span class="line">		this.width = width || 50;</span><br><span class="line">		this.height = height || 50;</span><br><span class="line">		this.$elem = null;</span><br><span class="line">	&#125;,</span><br><span class="line">	insert: function($where)&#123;</span><br><span class="line">		if (this.$elem) &#123;</span><br><span class="line">			this.$elem.css( &#123;</span><br><span class="line">				width: this.width + &quot;px&quot;,</span><br><span class="line">				height: this.height + &quot;px&quot;</span><br><span class="line">			&#125; ).appendTo( $where );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var Button = Object.create( Widget );</span><br><span class="line"></span><br><span class="line">Button.setup = function(width,height,label)&#123;</span><br><span class="line">	// delegated call</span><br><span class="line">	this.init( width, height );</span><br><span class="line">	this.label = label || &quot;Default&quot;;</span><br><span class="line"></span><br><span class="line">	this.$elem = $( &quot;&lt;button&gt;&quot; ).text( this.label );</span><br><span class="line">&#125;;</span><br><span class="line">Button.build = function($where) &#123;</span><br><span class="line">	// delegated call</span><br><span class="line">	this.insert( $where );</span><br><span class="line">	this.$elem.click( this.onClick.bind( this ) );</span><br><span class="line">&#125;;</span><br><span class="line">Button.onClick = function(evt) &#123;</span><br><span class="line">	console.log( &quot;Button &apos;&quot; + this.label + &quot;&apos; clicked!&quot; );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$( document ).ready( function()&#123;</span><br><span class="line">	var $body = $( document.body );</span><br><span class="line"></span><br><span class="line">	var btn1 = Object.create( Button );</span><br><span class="line">	btn1.setup( 125, 30, &quot;Hello&quot; );</span><br><span class="line"></span><br><span class="line">	var btn2 = Object.create( Button );</span><br><span class="line">	btn2.setup( 150, 40, &quot;World&quot; );</span><br><span class="line"></span><br><span class="line">	btn1.build( $body );</span><br><span class="line">	btn2.build( $body );</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>不认为<code>Widget</code>是一个父类而<code>Button</code>是一个子类，<code>Wedget</code><strong>只是一个对象</strong> 和某种具体类型的部件也许想要代理到的工具的集合，而且<code>Button</code><strong>也只是一个独立的对象</strong></p>
<h1 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1><p>不管是什么方法在js中实现继承都是基于原型的。Object.create或者es6的class。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/22/原型与原型链/" data-id="cjtjs8kbb0007fgun2289924v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-this指向和闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/22/this指向和闭包/" class="article-date">
  <time datetime="2018-03-22T07:46:10.000Z" itemprop="datePublished">2018-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/22/this指向和闭包/">this指向与闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="this指向与闭包"><a href="#this指向与闭包" class="headerlink" title="this指向与闭包"></a>this指向与闭包</h1><h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p>咱们首先要弄清楚this是什么，它是怎么来的，以及它的作用。</p>
<p>先看js精粹里的一句话。</p>
<p><em>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了声明时定义的形式参数，每个函数还接收两个附加的参数： this和arguments。参数this在面向对象编程中非常重要，它的值取决于调用的模式</em></p>
<p>上面的这段话很好的解释了我们的疑问。this是函数自带的属性this引用的是函数据以执行的环境对象。</p>
<p>也就是说<strong>this的指向在函数定义的时候是确定不来的，只有在函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</strong> 。</p>
<p>书上简单的例子解释一下什么是this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">'red'</span></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">'blue'</span>&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">sayColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>.color)</span><br><span class="line"> &#125;</span><br><span class="line"> sayColor() <span class="comment">// 'red'</span></span><br><span class="line"> </span><br><span class="line"> o.sayColor = sayColor()</span><br><span class="line"> o.sayColor() <span class="comment">// 'blue'</span></span><br></pre></td></tr></table></figure>
<p>既然this的指向是根据调用的那总结一下有几种调用模式</p>
<h2 id="调用模式"><a href="#调用模式" class="headerlink" title="调用模式"></a>调用模式</h2><ol>
<li><p>方法调用模式</p>
<p>当一个函数被保存为对象的一个属性时，我们称它为一个方法。当一个方法被调用时，this被绑定到该对象。很简单不配代码。</p>
</li>
</ol>
<ol start="2">
<li><p>函数调用模式</p>
<p>当一个函数并非一个对象的属性时而是作为单独变量出现，在这种模式下，this指向为Global对象，在浏览器中就是window对象。这里其实有个问题。如果环境是es6默认启用严格模式的话，没有调用者的函数this是undefined。也就是说其实前面那个小例子是跑不出来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = add(3,4);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>构造器调用模式</p>
<p>在《从js进化到es》中原型里写过。new foo()。如果一个函数前面带上new来调用，那么背地里将会创建一个连接到该函数的prototype成员的新对象，同时this会绑定到那个新对象上。简单的说foo函数内部的this永远是new foo ()返回的对象</p>
</li>
<li><p>Apply调用模式</p>
<p>使用call·apply·bind这些内置函数时。this指的是绑定对象，也就是函数的第一个参数。</p>
</li>
<li><p>箭头函数</p>
<p>箭头函数和以上的都不一样，和上面的结论相反。因为这个是es6新增的。</p>
<p>箭头函数内部的this对象就是定义时所在的对象，而不是使用时所在的对象。也就是this指向固化。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下，就发现this指向不仅不混乱而且规律明显非常规矩。就上面几种指向，记住就行。</p>
<h1 id="对象查找"><a href="#对象查找" class="headerlink" title="对象查找"></a>对象查找</h1><p>对象查找可以分为变量查找和属性查找。为什么要说这个。因为这两个有关于js里的两条链。厘清基本的概念了才能对复杂的概念搞清楚。<strong>作用域链和原型链</strong></p>
<h2 id="变量的查找"><a href="#变量的查找" class="headerlink" title="变量的查找"></a>变量的查找</h2><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是<br>保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所<br>在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对<br>象在最开始时只包含一个变量，即 arguments 对象（这个对象在全局环境中是不存在的）。作用域链中<br>的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延<br>续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)　</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        foo = <span class="number">3</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(foo + <span class="string">','</span> + bar); <span class="comment">// 注意这一行</span></span><br><span class="line">        &#125;</span><br><span class="line">        c();</span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line">跑一下，结果是<span class="number">3</span>,<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>变量查找，即在作用域上进行查找。</p>
<p>变量的查找可以简单地遵守<strong>从下向上</strong>的原则，即：</p>
<ol>
<li><p>在函数<code>c</code>的范围内查找<code>foo</code>和<code>bar</code>，显然在<code>c</code>里面并没有<code>foo</code>和<code>bar</code>的声明，查找失败。</p>
</li>
<li><p>在包含<code>c</code>的函数，即函数<code>b</code>的范围内查找<code>foo</code>和<code>bar</code>，可以看到<code>b</code>里面只有对<code>foo</code>的赋值，并没有声明，查找失败。</p>
</li>
<li><p>在包括<code>b</code>的函数，即函数<code>a</code>的范围内查找<code>foo</code>和<code>bar</code>，可以找到<code>bar</code>的声明，因此确定<code>bar</code>为2。</p>
</li>
<li><p>由于<code>a</code>不被任何函数包含，那么就在全局作用域内查找<code>foo</code>，发现有<code>foo</code>的声明，因此确定<code>foo</code>的值为1。但是由于在函数b中，对这个foo有赋值，所以foo的值被修改为3。</p>
</li>
<li><p>完确定<code>foo</code>的值为3，<code>bar</code>的值为2，因此输出<code>3,2</code>。</p>
</li>
</ol>
<p>看下图</p>
<p><img src="assets/0060lm7Tly1fo5zv0yiufj309k08tglo.jpg" alt="img"></p>
<p>矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但<br>外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p>
<h2 id="属性的查找"><a href="#属性的查找" class="headerlink" title="属性的查找"></a>属性的查找</h2><p>属性查找，即在原型链上进行查找。在上一篇原型里写了很多。不做赘述</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">b.prototype = <span class="keyword">new</span> a();</span><br><span class="line">c.prototype = <span class="keyword">new</span> b();</span><br><span class="line">a.prototype.foo = <span class="number">1</span>;</span><br><span class="line">b.prototype.bar = <span class="number">2</span>;</span><br><span class="line">c.prototype.foo = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> c();</span><br><span class="line"><span class="built_in">console</span>.log(o.foo + <span class="string">','</span> + o.bar); <span class="comment">// 这一行进行查找</span></span><br></pre></td></tr></table></figure>
<ol>
<li>查找<code>c.prototype</code>中，有没有显示定义<code>foo</code>和<code>bar</code>，发现定义了<code>foo</code>，其值为3。</li>
<li>发现<code>c.prototype</code>就是<code>new b()</code>得到的对象，那么查找<code>b.prototype</code>中，有没有显示定义<code>bar</code>，发现定义了，其值为2。</li>
<li>因此确定<code>foo</code>的值为3，<code>bar</code>的值为2，输出”3,2”。</li>
</ol>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>从上面的作用域链可以看出，函数内部可以读取上一层的变量。函数外部是无法读取函数内的局部变量的。但是，如果我们需要这样呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">　　　　<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">var</span> result=f1();</span><br><span class="line"></span><br><span class="line">　　result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</p>
<p>闭包就和上面的例子一样。能够读取其他函数内部变量的函数。由于在js里，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成‘定义在一个函数内部的函数’，所以本质上，闭包就是讲函数内部和函数外部链接起来的一座桥梁。</p>
<h2 id="深入理解闭包"><a href="#深入理解闭包" class="headerlink" title="深入理解闭包"></a>深入理解闭包</h2><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>匿名函数很简单就是没名字的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                       </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Lee'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数是匿名函数没错，但是跑不起来的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;            </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Lee'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">alert(box());</span><br></pre></td></tr></table></figure>
<p>这是一种方法，很简单。给个名字，把匿名函数赋值给变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;                      </span><br><span class="line">    alert(&apos;Lee&apos;);</span><br><span class="line">&#125;)();//也可以加个参数</span><br></pre></td></tr></table></figure>
<p>还有一种就是封装成表达式，定义并立即调用一个匿名函数。也叫<em>立即执行</em> 函数。在匿名函数外面国商一个（）把函数声明转化成函数表达式在用（）立即调用。这样就行了。当然匿名函数的写法还有<code>(function(){ .. }())</code>。</p>
<h3 id="理解闭包"><a href="#理解闭包" class="headerlink" title="理解闭包"></a>理解闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">输出结果：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>先来看这个代码，这段代码和更上面的代码（　　result(); // 999）有什么相同点？</p>
<p>baz()函数在foo()函数的作用域中声明，在bar()函数的作用域中被调用。但是可以看到依然可以输出值a = 2，而a是在foo函数的作用域中定义的。</p>
<p>两段代码的共同点就是一个函数在它编写时的词法作用域之外被调用。<em>闭包</em> 使这个函数可以继续访问它在编写时被定义的词法作用域。</p>
<h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>即上一节匿名函数里讲的立即执行函数。<strong>I</strong>mmediately <strong>I</strong>nvoked <strong>F</strong>unction <strong>E</strong> xpression——也被翻译为‘立即被调用的函数表达式’。当然有名字的也可以立即执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 2;</span><br><span class="line"></span><br><span class="line">(function foo()&#123;</span><br><span class="line"></span><br><span class="line">	var a = 3;</span><br><span class="line">	console.log( a ); // 3</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log( a ); // 2</span><br></pre></td></tr></table></figure>
<p>为什么要单独说IIFE呢？因为很多博客说闭包的时候就会拿这个来说，但是有不少反对意见。</p>
<p>严格来说，闭包需要满足三个条件：【1】访问所在作用域；【2】函数嵌套；【3】在所在作用域外被调用。IIFE仅仅满足了条件1。所以不能说是闭包，但是它创造了作用域。</p>
<h3 id="经典的循环代码"><a href="#经典的循环代码" class="headerlink" title="经典的循环代码"></a>经典的循环代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i&lt;=5; i++) &#123;</span><br><span class="line">	setTimeout( function timer()&#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码的目的很简单，就是输出1,2,3,4,5但是，如果跑一下就会发现输出了5次6。</p>
<p>6的来历自然是第一次不满足循环条件的i值。所以输出的结果是i在循环终结后的最终值。</p>
<p>由于作用域的工作方式，它们 <strong>都闭包在同一个共享的全局作用域上</strong>，而它事实上只有一个 <code>i</code>。</p>
<p>原因很简单：作用域问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (var i=1; i&lt;=5; i++) &#123;</span><br><span class="line">	(function()&#123;</span><br><span class="line">		var j = i;</span><br><span class="line">		setTimeout( function timer()&#123;</span><br><span class="line">			console.log( j );</span><br><span class="line">		&#125;, j*1000 );</span><br><span class="line">	&#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用IIFE为每个迭代都准备了新的被闭包的作用域。</p>
<p>更简单的es6解决办法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (let i=1; i&lt;=5; i++) &#123;</span><br><span class="line">	setTimeout( function timer()&#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该说这个才是正常的。复合直觉的写法。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>学完闭包最好的结果就是忘掉闭包。因为没有这个概念之前，该怎么调用就怎么调用。不会这个概念也会写。而且明白这个概念后最大的两个作用块级作用域和模块都已经在es6里有了新的简单的实现。如果编写代码时不自觉用到了就用，不要刻意的用闭包。</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>概念就是一个函数通过名字调用自身。没用过以后遇到再补充吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//斐波拉契题(兔子生兔子题目)--从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少</span><br><span class="line">// 产量分析：1， 1， 2， 3， 5， 8， 13， 21 。。。</span><br><span class="line">// 第n个月的兔子总数  =  第n-1个月的兔子总数 + 第n-2个月的兔子总数</span><br><span class="line">// 问题： 求任意月兔子的总数</span><br><span class="line"></span><br><span class="line">function func( n )</span><br><span class="line">&#123;</span><br><span class="line">    if (n == 0 || n == 1)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return func(n-1) + func(n-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = func(22);</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
<h1 id="for-in-和for-of"><a href="#for-in-和for-of" class="headerlink" title="for in 和for of"></a>for in 和for of</h1><p>for in是ES5标准，遍历key.</p>
<p>for of是ES6标准，遍历value.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];</span><br><span class="line"></span><br><span class="line">for (let a in arr) &#123;</span><br><span class="line">  console.log(a); // 0 1 2 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let a of arr) &#123;</span><br><span class="line">  console.log(a); // a b c d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for of可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、Generator 对象，以及字符串。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/22/this指向和闭包/" data-id="cjtjs8kb20004fguncn8cgiid" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-重温JS(1)-类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/22/重温JS(1)-类型/" class="article-date">
  <time datetime="2018-02-22T02:39:41.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/22/重温JS(1)-类型/">ss</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="重温JS-1-类型"><a href="#重温JS-1-类型" class="headerlink" title="重温JS(1)-类型"></a>重温JS(1)-类型</h1><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>七种数据数据类型，本篇博客主要讲数组和对象。</p>
<p>这篇博客不区分es6与js的差异。以es6为准。</p>
<p>js中变量没有类型而值有类型：基本数据类型值和引用类型值。<em>基本类型</em>就是简单的数据段。有五种：Undefined·Null·Boolean·Number·String。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p>
<p><em>引用类型</em>的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。有如下几种：Object·Array·Date·Regexp·Function·Boolean·Number·String。后面三种是为了便于操作基本类型值而提供的。</p>
<p>以上是《js高程》上的分类方法。但是如果直接写原始数据类型的话，有这七种：</p>
<ul>
<li><p><code>null</code></p>
</li>
<li><p><code>undefined</code></p>
</li>
<li><p><code>boolean</code></p>
</li>
<li><p><code>number</code></p>
</li>
<li><p><code>string</code></p>
</li>
<li><p><code>object</code></p>
</li>
<li><p><code>symbol</code> – 在ES6中被加入的！</p>
<p>很多子类型可以直接并入对象。</p>
</li>
</ul>
<h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><p>如果按照七种分法把数据类型分类就很好了。为什么还要按照《js高程》上面分的那么复杂呢。因为复制操作的不同。</p>
<h3 id="值与引用"><a href="#值与引用" class="headerlink" title="值与引用"></a>值与引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num1 = 5</span><br><span class="line">let num2 = num1</span><br></pre></td></tr></table></figure>
<p>在基本类型中变量复制另一个变量。复制后的结果是独立的。如下图</p>
<p><img src="assets/9GjmEq-1553222822386.png" alt="img"></p>
<p>这样导致的结果就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let a = 2</span><br><span class="line">let b = a</span><br><span class="line"></span><br><span class="line">console.log( &apos;修改前的b=&apos;+b );</span><br><span class="line">b = 3</span><br><span class="line">console.log(&apos;修改后的b=&apos;+b);</span><br><span class="line">console.log(&apos;修改后的a=&apos;+a);</span><br><span class="line">// 控制台结果</span><br><span class="line">修改前的b=2</span><br><span class="line"></span><br><span class="line">修改后的b=3</span><br><span class="line"></span><br><span class="line">修改后的a=2</span><br></pre></td></tr></table></figure>
<p>可以看到修改了b并不影响a。两者独立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = new Object()</span><br><span class="line">let obj2 = obj1</span><br><span class="line">obj1.name = &apos;snail&apos;</span><br><span class="line">alert(obj2.name)</span><br></pre></td></tr></table></figure>
<p>在引用类型中。复制操作结束后，两个变量实际上讲引用同一个对象。因此改变一个变量就会影响另一变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = new Object()</span><br><span class="line">let obj2 = obj1</span><br><span class="line">obj1.name = &apos;snail&apos;</span><br><span class="line">alert(obj2.name)</span><br><span class="line">obj2.name = &apos;fox&apos;</span><br><span class="line">alert(obj1.name)</span><br><span class="line">// </span><br><span class="line">snail</span><br><span class="line">fox</span><br></pre></td></tr></table></figure>
<p><img src="assets/9GjdPK-1553222822515.png" alt="img"></p>
<p>在此之上 ，函数的参数会有一个有关的问题。在函数篇讨论。</p>
<h1 id="值类型-1"><a href="#值类型-1" class="headerlink" title="值类型"></a>值类型</h1><p>在上面区分过复制操作后。下面的类型讲解就按照</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>object</code></li>
<li><code>symbol</code></li>
</ul>
<h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     === &quot;undefined&quot;; // true</span><br><span class="line">typeof true          === &quot;boolean&quot;;   // true</span><br><span class="line">typeof 42            === &quot;number&quot;;    // true</span><br><span class="line">typeof &quot;42&quot;          === &quot;string&quot;;    // true</span><br><span class="line">typeof &#123; life: 42 &#125;  === &quot;object&quot;;    // true</span><br><span class="line">typeof Symbol()      === &quot;symbol&quot;;    // true</span><br><span class="line">typeof null === &quot;object&quot;; </span><br><span class="line">// true</span><br><span class="line">typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;</span><br><span class="line">// true</span><br><span class="line">typeof function a()&#123; /* .. */ &#125; === &quot;Object&quot;</span><br><span class="line">// false</span><br><span class="line">typeof [1,2,3] === &quot;object&quot;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>如果要检测类型就用typeof。console.log一下在控制台中就可以看到结果。但是，<em>眼见不一定为实</em> 。</p>
<p>null不是对象，但是检测出来却是对象据说是个存在20年的bug不可能修复了。因为浏览器规范的原因，检测函数返回function这个倒是挺对的。但是却会让人误会函数是顶层的内建类型，其实函数是对象的子类型。同样的数组也是对象的子类型。</p>
<p>如果你想要使用<code>null</code>类型来测试<code>null</code>值，你需要一个复合条件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="判断类型的四种方法"><a href="#判断类型的四种方法" class="headerlink" title="判断类型的四种方法"></a>判断类型的四种方法</h2><ol>
<li><p>typeof<br>上面写了不可靠。</p>
</li>
<li><p>instanceof</p>
<p>instanceof用来判断A是否是B的实例。当 A 的 [[proto]] 指向 B 的 prototype 时,就会返回true</p>
</li>
</ol>
<p>​    因为这个方法的原理所有数组的判断结果对Object与Array都是true。<code>String和`</code>Date<code>对象同时也属于</code>Object<code>类型（他们是由</code>Object`类派生出来的）。所以它只能用来检测原型与构造函数不能用来检测类型</p>
<ol start="3">
<li><p>toString</p>
<p>这个常用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="string">''</span><span class="string">``</span>) ;  <span class="string">``</span><span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;   <span class="string">``</span><span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="literal">true</span><span class="string">``</span>) ;<span class="string">``</span><span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>());<span class="string">``</span><span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ;<span class="string">``</span><span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="literal">null</span><span class="string">``</span>) ;<span class="string">``</span><span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Function</span>()) ;<span class="string">``</span><span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Date</span>()) ;<span class="string">``</span><span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ;<span class="string">``</span><span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">RegExp</span>()) ;<span class="string">``</span><span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Error</span>()) ;<span class="string">``</span><span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ;<span class="string">``</span><span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ;<span class="string">``</span><span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="值类型-2"><a href="#值类型-2" class="headerlink" title="值类型"></a>值类型</h2><p>《you-dont-know-js》中把array·string·number称为值类型。《js高程》里讲Boolean·Number·String称为基本包装类型。这篇博客统称为值类型。因为不管叫什么怎么分，这些数据类型的目的就是为了操作值。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>在js中array只是值的容器。这些值可以是任何类型：<code>string</code>或者<code>number</code>或者<code>object</code>，甚至是另一个<code>array</code>（这也是你得到多维数组的方法）。数组的大小也是可以动态调整的。也就是随着数据的添加自动增长。真的是非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = [ ];</span><br><span class="line"></span><br><span class="line">a.length;	// 0</span><br><span class="line"></span><br><span class="line">a[0] = 1;</span><br><span class="line">a[1] = &quot;2&quot;;</span><br><span class="line">a[2] = [ 3 ];</span><br><span class="line"></span><br><span class="line">a.length;	// 3</span><br></pre></td></tr></table></figure>
<p>创建数组的方法有两种。</p>
<p>第一种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors = new Array(); </span><br><span class="line">let colors = Array(3);             // 创建一个包含 3 项的数组 </span><br><span class="line">let names = Array(&quot;Greg&quot;);   // 创建一个包含 1 项，即字符串&quot;Greg&quot;的数组</span><br><span class="line">Array.of(1) // [1]</span><br></pre></td></tr></table></figure>
<p>第二种 字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="数组的方法和属性"><a href="#数组的方法和属性" class="headerlink" title="数组的方法和属性"></a>数组的方法和属性</h3><h4 id="访问和长度"><a href="#访问和长度" class="headerlink" title="访问和长度"></a>访问和长度</h4><p>属性有length属性。以及继承的函数和对象的属性和方法，都暂略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">alert(colors[0]);   </span><br><span class="line">colors[colors.length] = &quot;black&quot;;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始下标为0，colors[0]。</li>
<li>有一个属性length，可以修改。</li>
<li>length不一定等于数组里的属性的个数。但是它一定等于这个数组的最大整数属性名加1。</li>
<li>数组最后一项的索引始终是 length-1</li>
<li>修改length后如果初始有5项，将length修改为3。过小。就会导致下标大于新length的属性被删除。</li>
<li>同理，想添加进最后一项也可以colors[colors.length] = “black”;</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>检测数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(value))&#123; </span><br><span class="line">    //对数组执行某些操作 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>扩展运算符</p>
<p>将一个数组转为用逗号分隔的参数序列。主要用于函数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) //这一行的...是rest参数。</span><br><span class="line">&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>增删操作</p>
<p>push()末尾增加·pop()末尾移除。</p>
<p>shift()头部移除·unshift头部增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">push返回的是修改后的长度</span><br><span class="line">pop返回的是移除的那一项</span><br><span class="line">shift返回的是移除的那一项</span><br><span class="line">unshift返回的是修改后的长度</span><br><span class="line">增加返回的都是长度，删除返回的是那一项。</span><br><span class="line"></span><br><span class="line">var colors = new Array();                  // 创建一个数组 </span><br><span class="line">var count = colors.push(&quot;red&quot;, &quot;green&quot;);   // 推入两项 </span><br><span class="line">alert(count);  //2 </span><br><span class="line"> </span><br><span class="line">count = colors.push(&quot;black&quot;);              // 推入另一项 </span><br><span class="line">alert(count);     //3 </span><br><span class="line"> </span><br><span class="line">var item = colors.pop();                  // 取得最后一项 </span><br><span class="line">alert(item);      //&quot;black&quot; </span><br><span class="line">alert(colors.length);   //2 </span><br><span class="line">var item = colors.shift();                  //取得第一项 </span><br><span class="line">alert(item);      //&quot;red&quot; </span><br><span class="line">alert(colors.length); //2 </span><br><span class="line">count = colors.unshift(&quot;black&quot;);                //推入另一项 </span><br><span class="line">alert(count);   //3</span><br></pre></td></tr></table></figure>
</li>
<li><p>重排序</p>
<p>reverse()反转数组项顺序</p>
<p>sort()升序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4, 5]; </span><br><span class="line">values.reverse(); </span><br><span class="line">alert(values);        //5,4,3,2,1 </span><br><span class="line">var values = [0, 1, 5, 10, 15]; </span><br><span class="line">values.sort(); </span><br><span class="line">alert(values);   //0,1,10,15,5 结果不理想</span><br><span class="line">//sort()也可以接受比较函数作为参数，修改为降序</span><br><span class="line">function compare(value1, value2) &#123; </span><br><span class="line">    if (value1 &lt; value2) &#123; </span><br><span class="line">        return 1; </span><br><span class="line">    &#125; else if (value1 &gt; value2) &#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        return 0; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var values = [0, 1, 5, 10, 15]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values);    // 15,10,5,1,0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>复制与合并</p>
<p>数组并不是基本类型值，如果直接=也只是复制了一个指针，如上面的代码一样会互相影响。所以复制操作不能简单的=。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//es5写法</span><br><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] = 2;//修改a2并不改变a1</span><br><span class="line">a1 // [1, 2]</span><br><span class="line">//es6写法</span><br><span class="line">const a1 = [1, 2];</span><br><span class="line">// 写法一</span><br><span class="line">const a2 = [...a1];</span><br><span class="line">// 写法二</span><br><span class="line">const [...a2] = a1;</span><br><span class="line"></span><br><span class="line">合并</span><br><span class="line">let arr1 = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">let arr2 = [&apos;c&apos;];</span><br><span class="line">let arr3 = [&apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// ES5的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br><span class="line"></span><br><span class="line">// ES6的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>splice</p>
<p>slice()的返回值是一个数组。接受三个参数。第一个为起始位置。第二个为删除的项数，第三个为插入的项。一个方法就可以实现可以实现增删改的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </span><br><span class="line">let removed = colors.splice(0,1);                // 删除第一项 </span><br><span class="line">alert(colors);     // green,blue </span><br><span class="line">alert(removed);    // red，返回的数组中只包含一项 </span><br><span class="line"> </span><br><span class="line">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);   // 从位置 1 开始插入两项 </span><br><span class="line">alert(colors);     // green,yellow,orange,blue </span><br><span class="line">alert(removed);    // 返回的是一个空数组 </span><br><span class="line"> </span><br><span class="line">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);      // 插入两项，删除一项 </span><br><span class="line">alert(colors);     // green,red,purple,orange,blue </span><br><span class="line">alert(removed);    // yellow，返回的数组中只包含一项</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p>转换</p>
<p>Array.from()用于将两类对象转化为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p>Array.of()用于将一组值转化为数组</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设设置一个数组长度为1，值为2.</span><br><span class="line">Array(2)的结果是一个长度为2的空数组。</span><br><span class="line">Array.of()则可以按目的显示。</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br><span class="line"></span><br><span class="line">Array.of(7);       // [7] </span><br><span class="line">Array.of(1, 2, 3); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">Array(7);          // [ , , , , , , ]</span><br><span class="line">Array(1, 2, 3);    // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>   join() 方法将一个数组（或一个<a href="https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects" target="_blank" rel="noopener">类数组对象</a>）的所有元素连接成一个字符串并返回这个字符串。</p>
<ol start="8">
<li><p>位置</p>
<p>indexOf()和 lastIndexOf()。这两个方法都接收<br>两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位<br>置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。</p>
<p>es6新增了find()返回值和findIndex()返回索引，都是接收一个测试函数作为第一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">alert(numbers.indexOf(4));        //3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line">function f(v)&#123;</span><br><span class="line">  return v &gt; this.age;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;name: &apos;John&apos;, age: 20&#125;;</span><br><span class="line">[10, 12, 26, 15].find(f, person);    // 26</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="9">
<li><p>迭代</p>
<p><strong>对数组进行操作</strong> 还是非常重要的。</p>
<p>ECMAScript 5为数组定义了 5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和<br>（可选的）运行该函数的作用域对象——影响 this 的值。</p>
</li>
</ol>
<p>    every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。<br>    filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。<br>    forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。<br>    map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>    some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">var filterResult = numbers.filter(function(item, index, array)&#123; </span><br><span class="line">    return (item &gt; 2); </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">alert(filterResult);  //[3,4,5,4,3] </span><br><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">var mapResult = numbers.map(function(item, index, array)&#123; </span><br><span class="line">    return item * 2; </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure>
<ol start="10">
<li><p>归并</p>
<p>reduce()和 reduceRight()。这两个方法都会迭<br>代数组的所有项，然后构建一个最终返回的值。可以做累加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5]; </span><br><span class="line">var sum = values.reduce(function(prev, cur, index, array)&#123; </span><br><span class="line">    return prev + cur;  </span><br><span class="line">&#125;); </span><br><span class="line">alert(sum); //15</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="11">
<li><p>fill</p>
<p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line">第二个和第三个参数用于指定填充的起始位置和结束位置</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</span><br><span class="line">// [&apos;a&apos;, 7, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法也是es6新增，知乎有个问题</p>
<p>JavaScript 怎么快速声明一个数组，长度为 100，元素全是 0？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(100), i=arr.length;</span><br><span class="line">while(i--)&#123;arr[i] = 0;&#125;</span><br><span class="line">或者</span><br><span class="line">Array.apply(null,Array(100)).map(function(item, i) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在es6里就只需要很短的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(100).fill(0)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>includes</p>
<p>返回一个布尔值，表示某个数组是否包含给定的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // true</span><br><span class="line">[1, 2, 3].includes(4)     // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多具体的方法和参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">点这里</a>。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串有两个特点：一·类似数组、二·不可变。</p>
<p>也就是说没办法原地修改内容的。</p>
<p>这里有两个方法，split讲一个string对象分隔成字符串数组，join将一个数组所有元素连接成字符串并返回这个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a =&apos;foo&apos;</span><br><span class="line">let c = a</span><br><span class="line">        .split(&apos;&apos;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">console.log(c)//oof</span><br></pre></td></tr></table></figure>
<p>借用数组的反转来反转字符串。</p>
<p>模板字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function authorize(user, action) &#123;</span><br><span class="line">  if (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    throw new Error(</span><br><span class="line">      // 传统写法为</span><br><span class="line">      // &apos;User &apos;</span><br><span class="line">      // + user.name</span><br><span class="line">      // + &apos; is not authorized to do &apos;</span><br><span class="line">      // + action</span><br><span class="line">      // + &apos;.&apos;</span><br><span class="line">      `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多api不赘述，看文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">点击这里</a>.<a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">es6新增点这里</a></p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>并没有分离出整数类型，1和1.0相同。就像java里的<strong>double</strong></p>
<p>有一个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3; // false</span><br><span class="line">0.30000000000000004</span><br><span class="line">在es6中新增了Number.EPSILON表示容差</span><br><span class="line">function numbersCloseEnoughToEqual(n1,n2) &#123;</span><br><span class="line">	return Math.abs( n1 - n2 ) &lt; Number.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 0.1 + 0.2;</span><br><span class="line">var b = 0.3;</span><br><span class="line"></span><br><span class="line">numbersCloseEnoughToEqual( a, b );					// true</span><br><span class="line">numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );	// false</span><br></pre></td></tr></table></figure>
<p>二进制浮点数的原因。</p>
<p>一些方法就不抄了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt" target="_blank" rel="noopener">点这里</a><a href="http://es6.ruanyifeng.com/#docs/number" target="_blank" rel="noopener">es6新增点这里</a></p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>如果操作本来要返回数值但是未返回数值的情况下，js中并不会抛出错误而是返回NaN。NaN不等于自身</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>对于<code>undefined</code>类型来说，有且仅有一个值：<code>undefined</code>。对于<code>null</code>类型来说，有且仅有一个值：<code>null</code>。所以对它们而言，这些文字既是它们的类型也是它们的值。</p>
<p>undefined翻译一下就是未定义。声明了一个变量但是没有初始化的时候，这个变量的值就是undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var message; </span><br><span class="line">alert(message == undefined); //true</span><br></pre></td></tr></table></figure>
<p>null值表示一个空对象指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var car = null; </span><br><span class="line">alert(typeof car);     // &quot;object&quot; </span><br><span class="line"> </span><br><span class="line">if (car != null)&#123; </span><br><span class="line">    // 对 car 对象执行某些操作 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会返回一个对象，前面说是一个bug。但就算是个bug也是有来由的。</p>
<blockquote>
<p>无论在什么情况下<br>都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，<br>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以<br>体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。</p>
</blockquote>
<p>null本来就是用于对象。bug也就bug了。</p>
<p>还有一点undefined是一个标识符。但是别用。所有不赘述。</p>
<p>Boolean</p>
<p>也就是true和false。区分大小写，可以用Boolean转换其他值为对应布尔值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var message = &quot;Hello world!&quot;; </span><br><span class="line">var messageAsBoolean = Boolean(message); </span><br><span class="line"> 跑一下</span><br><span class="line">  console.log(messageAsBoolean);</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转化为true</th>
<th>false</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>‘’(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数值</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>不适用</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>上表就是一些数据类型转化为布尔值的规则。还有一些其他问题在下一节类型转化讨论。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在js中 三种基本值<code>string</code>，<code>number</code>，或<code>boolean</code>可以发生类型转换 。可以分为隐含强制转换和明确强制转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 42;</span><br><span class="line"></span><br><span class="line">var b = a + &quot;&quot;;			// 隐含强制转换</span><br><span class="line"></span><br><span class="line">var c = String( a );	// 明确强制转换</span><br><span class="line">跑一下</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(c);</span><br><span class="line">// 结果42 42</span><br></pre></td></tr></table></figure>
<h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p>在布尔值一节有个表格，总结转换规则。现在把转换规则再总结</p>
<ul>
<li><p><code>undefined</code></p>
</li>
<li><p><code>null</code></p>
</li>
<li><p><code>false</code></p>
</li>
<li><p><code>+0</code>, <code>-0</code>, and <code>NaN</code></p>
</li>
<li><p><code>&quot;&quot;</code></p>
</li>
</ul>
<p>除去可以变为false的被称为falsy，其他全部变为true被称为truthy。</p>
<p><strong>如果一个值不在falsy列表中，它就是truthy</strong>。</p>
<p>这样就有一些代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if （function foo）&#123;</span><br><span class="line">	do something</span><br><span class="line">&#125;</span><br><span class="line">隐性的做了逻辑判断</span><br></pre></td></tr></table></figure>
<p>一些更复杂的细碎的例子<a href="https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md" target="_blank" rel="noopener">点这里</a></p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>js中出了基本值外，其他所有值都是对象。</p>
<p>对象是属性的容器，属性名总是字符串。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object(); </span><br><span class="line">person.name = &quot;Nicholas&quot;; </span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure>
<p>对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; </span><br><span class="line">    name : &quot;Nicholas&quot;, </span><br><span class="line">    age : 29 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="es6中对象的扩展"><a href="#es6中对象的扩展" class="headerlink" title="es6中对象的扩展"></a>es6中对象的扩展</h2><p>一些对象的基本知识不赘述。这里只总结Object在es6中的扩展</p>
<ol>
<li><p>简洁表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">属性和方法简写</span><br><span class="line">允许直接写入变量和函数，作为对象的属性和方法。方法也可以省个function。</span><br><span class="line">let birth = &apos;2000/01/01&apos;;</span><br><span class="line"></span><br><span class="line">const Person = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line"></span><br><span class="line">  //等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line"></span><br><span class="line">  // 等同于hello: function ()...</span><br><span class="line">  hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>属性名表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用对象字面量定义对象时，可以把表达式作为对象的属性名</span><br><span class="line">let propKey = &apos;foo&apos;;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [propKey]: true,</span><br><span class="line">  [&apos;a&apos; + &apos;bc&apos;]: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>方法的name属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数有name属性，对象的方法是函数所以也有name属性。</span><br><span class="line">const person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(&apos;hello!&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   // &quot;sayName&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>Object.is</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0</span><br><span class="line">它用来比较两个值是否严格相等</span><br><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>Object.assign</p>
<p>用于对象的合并。讲原对象的所有可枚举属性复制到目标对象，注意：浅拷贝·同名属性替换·取值函数会把值复制过去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>属性的可枚举和遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</span><br><span class="line">let obj = &#123; foo: 123 &#125;</span><br><span class="line">let a = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</span><br><span class="line">console.log(a);</span><br><span class="line">//configurable: true</span><br><span class="line">enumerable: true</span><br><span class="line">value: 123</span><br><span class="line">writable: true</span><br><span class="line"></span><br><span class="line">其中enumerable属性就是可枚举型</span><br></pre></td></tr></table></figure>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
</li>
<li><p>Object.getOwnPropertyDescriptor</p>
<p>一些高级用法，没用过就不复制粘贴了。以后用过再写。</p>
</li>
<li><p>[[Prototype]]的新增方法</p>
<p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let proto = &#123;&#125;;</span><br><span class="line">let obj = &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line"></span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br><span class="line">将proto对象设为了obj对象的原型。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf用于读取一个对象的原型对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>super关键字</p>
<p>super指向当前对象的原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const proto = &#123;</span><br><span class="line">  foo: &apos;hello&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() // &quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="10">
<li><p>Object.create</p>
<p>该方法会使用指定的原型对象及其属性去创建一个新的对象。该方法用于模仿继承。在原型篇详细些。</p>
</li>
</ol>
<h2 id="Date类型和RegExp类型"><a href="#Date类型和RegExp类型" class="headerlink" title="Date类型和RegExp类型"></a>Date类型和RegExp类型</h2><p>全是一些方法，写了也是复制粘贴一大串。</p>
<p>没什么特殊的地方<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">点这里看</a></p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是一种新机制可以保证每个属性的名字独一无二。</p>
<p>Symbol值通过Symbol函数生成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure>
<p>用作属性名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>如果想实现应用同样的Symbol值，可以使用Symbol.for(‘字符串值’),返回一个宜家登记的Symbol值。</p>
<h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>简单的说set类似于数组，但是成员的值都是唯一的，没有重复。<code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br><span class="line"></span><br><span class="line">// 例三</span><br><span class="line">const <span class="keyword">set</span> = new Set(document.querySelectorAll('div'));</span><br><span class="line"><span class="keyword">set</span>.size // 56</span><br><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br><span class="line">[...new Set('ababbc')].join('')</span><br><span class="line">// "abc"</span><br></pre></td></tr></table></figure>
<p>操作方法暂时不写，确实没怎么用过。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
<p>使用方法暂时不写，确实没怎么用过</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>js中的类型松散。基本类型不像其他语言分的那么细。而且还有隐含的强制转换。用的时候即方便又要倍加小心。引用类型就是Object对象的子类型。有个固有的属性和方法。而这些属性和方法是建立在原型上的。有关原型，拷贝，继承等等都不在这篇博客说了。本篇博客主要总结了一些内建类型的原生方法。以后随时增删。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/22/重温JS(1)-类型/" data-id="cjtjs8kbj0009fguntt7wnd6z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/22/sa/">sa</a>
          </li>
        
          <li>
            <a href="/2019/03/22/ssss/">ssss</a>
          </li>
        
          <li>
            <a href="/2019/03/22/ss/">ss</a>
          </li>
        
          <li>
            <a href="/2019/03/20/写博客/">写博客</a>
          </li>
        
          <li>
            <a href="/2019/02/22/原型与原型链/">原型链与继承</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 李向<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>