<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>ss | 李向的笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="重温JS(1)-类型导语七种数据数据类型，本篇博客主要讲数组和对象。 这篇博客不区分es6与js的差异。以es6为准。 js中变量没有类型而值有类型：基本数据类型值和引用类型值。基本类型就是简单的数据段。有五种：Undefined·Null·Boolean·Number·String。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。 引用类型的值是保存在内存中的对象。在操作对象时，实">
<meta name="keywords" content="JS">
<meta property="og:type" content="article">
<meta property="og:title" content="ss">
<meta property="og:url" content="http://yoursite.com/2018/02/22/重温JS(1)-类型/index.html">
<meta property="og:site_name" content="李向的笔记">
<meta property="og:description" content="重温JS(1)-类型导语七种数据数据类型，本篇博客主要讲数组和对象。 这篇博客不区分es6与js的差异。以es6为准。 js中变量没有类型而值有类型：基本数据类型值和引用类型值。基本类型就是简单的数据段。有五种：Undefined·Null·Boolean·Number·String。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。 引用类型的值是保存在内存中的对象。在操作对象时，实">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/02/22/重温JS(1)-类型/assets/9GjmEq-1553222822386.png">
<meta property="og:image" content="http://yoursite.com/2018/02/22/重温JS(1)-类型/assets/9GjdPK-1553222822515.png">
<meta property="og:updated_time" content="2019-03-22T03:35:27.118Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ss">
<meta name="twitter:description" content="重温JS(1)-类型导语七种数据数据类型，本篇博客主要讲数组和对象。 这篇博客不区分es6与js的差异。以es6为准。 js中变量没有类型而值有类型：基本数据类型值和引用类型值。基本类型就是简单的数据段。有五种：Undefined·Null·Boolean·Number·String。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。 引用类型的值是保存在内存中的对象。在操作对象时，实">
<meta name="twitter:image" content="http://yoursite.com/2018/02/22/重温JS(1)-类型/assets/9GjmEq-1553222822386.png">
  
    <link rel="alternate" href="/atom.xml" title="李向的笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">李向的笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-重温JS(1)-类型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/22/重温JS(1)-类型/" class="article-date">
  <time datetime="2018-02-22T02:39:41.000Z" itemprop="datePublished">2018-02-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ss
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="重温JS-1-类型"><a href="#重温JS-1-类型" class="headerlink" title="重温JS(1)-类型"></a>重温JS(1)-类型</h1><h1 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h1><p>七种数据数据类型，本篇博客主要讲数组和对象。</p>
<p>这篇博客不区分es6与js的差异。以es6为准。</p>
<p>js中变量没有类型而值有类型：基本数据类型值和引用类型值。<em>基本类型</em>就是简单的数据段。有五种：Undefined·Null·Boolean·Number·String。基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p>
<p><em>引用类型</em>的值是保存在内存中的对象。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。有如下几种：Object·Array·Date·Regexp·Function·Boolean·Number·String。后面三种是为了便于操作基本类型值而提供的。</p>
<p>以上是《js高程》上的分类方法。但是如果直接写原始数据类型的话，有这七种：</p>
<ul>
<li><p><code>null</code></p>
</li>
<li><p><code>undefined</code></p>
</li>
<li><p><code>boolean</code></p>
</li>
<li><p><code>number</code></p>
</li>
<li><p><code>string</code></p>
</li>
<li><p><code>object</code></p>
</li>
<li><p><code>symbol</code> – 在ES6中被加入的！</p>
<p>很多子类型可以直接并入对象。</p>
</li>
</ul>
<h1 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h1><p>如果按照七种分法把数据类型分类就很好了。为什么还要按照《js高程》上面分的那么复杂呢。因为复制操作的不同。</p>
<h3 id="值与引用"><a href="#值与引用" class="headerlink" title="值与引用"></a>值与引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num1 = 5</span><br><span class="line">let num2 = num1</span><br></pre></td></tr></table></figure>
<p>在基本类型中变量复制另一个变量。复制后的结果是独立的。如下图</p>
<p><img src="assets/9GjmEq-1553222822386.png" alt="img"></p>
<p>这样导致的结果就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let a = 2</span><br><span class="line">let b = a</span><br><span class="line"></span><br><span class="line">console.log( &apos;修改前的b=&apos;+b );</span><br><span class="line">b = 3</span><br><span class="line">console.log(&apos;修改后的b=&apos;+b);</span><br><span class="line">console.log(&apos;修改后的a=&apos;+a);</span><br><span class="line">// 控制台结果</span><br><span class="line">修改前的b=2</span><br><span class="line"></span><br><span class="line">修改后的b=3</span><br><span class="line"></span><br><span class="line">修改后的a=2</span><br></pre></td></tr></table></figure>
<p>可以看到修改了b并不影响a。两者独立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = new Object()</span><br><span class="line">let obj2 = obj1</span><br><span class="line">obj1.name = &apos;snail&apos;</span><br><span class="line">alert(obj2.name)</span><br></pre></td></tr></table></figure>
<p>在引用类型中。复制操作结束后，两个变量实际上讲引用同一个对象。因此改变一个变量就会影响另一变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = new Object()</span><br><span class="line">let obj2 = obj1</span><br><span class="line">obj1.name = &apos;snail&apos;</span><br><span class="line">alert(obj2.name)</span><br><span class="line">obj2.name = &apos;fox&apos;</span><br><span class="line">alert(obj1.name)</span><br><span class="line">// </span><br><span class="line">snail</span><br><span class="line">fox</span><br></pre></td></tr></table></figure>
<p><img src="assets/9GjdPK-1553222822515.png" alt="img"></p>
<p>在此之上 ，函数的参数会有一个有关的问题。在函数篇讨论。</p>
<h1 id="值类型-1"><a href="#值类型-1" class="headerlink" title="值类型"></a>值类型</h1><p>在上面区分过复制操作后。下面的类型讲解就按照</p>
<ul>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>boolean</code></li>
<li><code>number</code></li>
<li><code>string</code></li>
<li><code>object</code></li>
<li><code>symbol</code></li>
</ul>
<h2 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined     === &quot;undefined&quot;; // true</span><br><span class="line">typeof true          === &quot;boolean&quot;;   // true</span><br><span class="line">typeof 42            === &quot;number&quot;;    // true</span><br><span class="line">typeof &quot;42&quot;          === &quot;string&quot;;    // true</span><br><span class="line">typeof &#123; life: 42 &#125;  === &quot;object&quot;;    // true</span><br><span class="line">typeof Symbol()      === &quot;symbol&quot;;    // true</span><br><span class="line">typeof null === &quot;object&quot;; </span><br><span class="line">// true</span><br><span class="line">typeof function a()&#123; /* .. */ &#125; === &quot;function&quot;</span><br><span class="line">// true</span><br><span class="line">typeof function a()&#123; /* .. */ &#125; === &quot;Object&quot;</span><br><span class="line">// false</span><br><span class="line">typeof [1,2,3] === &quot;object&quot;</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>如果要检测类型就用typeof。console.log一下在控制台中就可以看到结果。但是，<em>眼见不一定为实</em> 。</p>
<p>null不是对象，但是检测出来却是对象据说是个存在20年的bug不可能修复了。因为浏览器规范的原因，检测函数返回function这个倒是挺对的。但是却会让人误会函数是顶层的内建类型，其实函数是对象的子类型。同样的数组也是对象的子类型。</p>
<p>如果你想要使用<code>null</code>类型来测试<code>null</code>值，你需要一个复合条件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="判断类型的四种方法"><a href="#判断类型的四种方法" class="headerlink" title="判断类型的四种方法"></a>判断类型的四种方法</h2><ol>
<li><p>typeof<br>上面写了不可靠。</p>
</li>
<li><p>instanceof</p>
<p>instanceof用来判断A是否是B的实例。当 A 的 [[proto]] 指向 B 的 prototype 时,就会返回true</p>
</li>
</ol>
<p>​    因为这个方法的原理所有数组的判断结果对Object与Array都是true。<code>String和`</code>Date<code>对象同时也属于</code>Object<code>类型（他们是由</code>Object`类派生出来的）。所以它只能用来检测原型与构造函数不能用来检测类型</p>
<ol start="3">
<li><p>toString</p>
<p>这个常用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="string">''</span><span class="string">``</span>) ;  <span class="string">``</span><span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) ;   <span class="string">``</span><span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="literal">true</span><span class="string">``</span>) ;<span class="string">``</span><span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>());<span class="string">``</span><span class="comment">//[object Symbol]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) ;<span class="string">``</span><span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="literal">null</span><span class="string">``</span>) ;<span class="string">``</span><span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Function</span>()) ;<span class="string">``</span><span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Date</span>()) ;<span class="string">``</span><span class="comment">// [object Date]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]) ;<span class="string">``</span><span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">RegExp</span>()) ;<span class="string">``</span><span class="comment">// [object RegExp]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">``</span><span class="keyword">new</span><span class="string">` `</span><span class="built_in">Error</span>()) ;<span class="string">``</span><span class="comment">// [object Error]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>) ;<span class="string">``</span><span class="comment">// [object HTMLDocument]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">window</span>) ;<span class="string">``</span><span class="comment">//[object global] window 是全局对象 global 的引用</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="值类型-2"><a href="#值类型-2" class="headerlink" title="值类型"></a>值类型</h2><p>《you-dont-know-js》中把array·string·number称为值类型。《js高程》里讲Boolean·Number·String称为基本包装类型。这篇博客统称为值类型。因为不管叫什么怎么分，这些数据类型的目的就是为了操作值。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>在js中array只是值的容器。这些值可以是任何类型：<code>string</code>或者<code>number</code>或者<code>object</code>，甚至是另一个<code>array</code>（这也是你得到多维数组的方法）。数组的大小也是可以动态调整的。也就是随着数据的添加自动增长。真的是非常方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = [ ];</span><br><span class="line"></span><br><span class="line">a.length;	// 0</span><br><span class="line"></span><br><span class="line">a[0] = 1;</span><br><span class="line">a[1] = &quot;2&quot;;</span><br><span class="line">a[2] = [ 3 ];</span><br><span class="line"></span><br><span class="line">a.length;	// 3</span><br></pre></td></tr></table></figure>
<p>创建数组的方法有两种。</p>
<p>第一种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let colors = new Array(); </span><br><span class="line">let colors = Array(3);             // 创建一个包含 3 项的数组 </span><br><span class="line">let names = Array(&quot;Greg&quot;);   // 创建一个包含 1 项，即字符串&quot;Greg&quot;的数组</span><br><span class="line">Array.of(1) // [1]</span><br></pre></td></tr></table></figure>
<p>第二种 字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br></pre></td></tr></table></figure>
<h3 id="数组的方法和属性"><a href="#数组的方法和属性" class="headerlink" title="数组的方法和属性"></a>数组的方法和属性</h3><h4 id="访问和长度"><a href="#访问和长度" class="headerlink" title="访问和长度"></a>访问和长度</h4><p>属性有length属性。以及继承的函数和对象的属性和方法，都暂略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</span><br><span class="line">alert(colors[0]);   </span><br><span class="line">colors[colors.length] = &quot;black&quot;;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始下标为0，colors[0]。</li>
<li>有一个属性length，可以修改。</li>
<li>length不一定等于数组里的属性的个数。但是它一定等于这个数组的最大整数属性名加1。</li>
<li>数组最后一项的索引始终是 length-1</li>
<li>修改length后如果初始有5项，将length修改为3。过小。就会导致下标大于新length的属性被删除。</li>
<li>同理，想添加进最后一项也可以colors[colors.length] = “black”;</li>
</ol>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ol>
<li><p>检测数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Array.isArray(value))&#123; </span><br><span class="line">    //对数组执行某些操作 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>扩展运算符</p>
<p>将一个数组转为用逗号分隔的参数序列。主要用于函数调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) //这一行的...是rest参数。</span><br><span class="line">&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>增删操作</p>
<p>push()末尾增加·pop()末尾移除。</p>
<p>shift()头部移除·unshift头部增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">push返回的是修改后的长度</span><br><span class="line">pop返回的是移除的那一项</span><br><span class="line">shift返回的是移除的那一项</span><br><span class="line">unshift返回的是修改后的长度</span><br><span class="line">增加返回的都是长度，删除返回的是那一项。</span><br><span class="line"></span><br><span class="line">var colors = new Array();                  // 创建一个数组 </span><br><span class="line">var count = colors.push(&quot;red&quot;, &quot;green&quot;);   // 推入两项 </span><br><span class="line">alert(count);  //2 </span><br><span class="line"> </span><br><span class="line">count = colors.push(&quot;black&quot;);              // 推入另一项 </span><br><span class="line">alert(count);     //3 </span><br><span class="line"> </span><br><span class="line">var item = colors.pop();                  // 取得最后一项 </span><br><span class="line">alert(item);      //&quot;black&quot; </span><br><span class="line">alert(colors.length);   //2 </span><br><span class="line">var item = colors.shift();                  //取得第一项 </span><br><span class="line">alert(item);      //&quot;red&quot; </span><br><span class="line">alert(colors.length); //2 </span><br><span class="line">count = colors.unshift(&quot;black&quot;);                //推入另一项 </span><br><span class="line">alert(count);   //3</span><br></pre></td></tr></table></figure>
</li>
<li><p>重排序</p>
<p>reverse()反转数组项顺序</p>
<p>sort()升序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var values = [1, 2, 3, 4, 5]; </span><br><span class="line">values.reverse(); </span><br><span class="line">alert(values);        //5,4,3,2,1 </span><br><span class="line">var values = [0, 1, 5, 10, 15]; </span><br><span class="line">values.sort(); </span><br><span class="line">alert(values);   //0,1,10,15,5 结果不理想</span><br><span class="line">//sort()也可以接受比较函数作为参数，修改为降序</span><br><span class="line">function compare(value1, value2) &#123; </span><br><span class="line">    if (value1 &lt; value2) &#123; </span><br><span class="line">        return 1; </span><br><span class="line">    &#125; else if (value1 &gt; value2) &#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125; else &#123; </span><br><span class="line">        return 0; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">var values = [0, 1, 5, 10, 15]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values);    // 15,10,5,1,0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>复制与合并</p>
<p>数组并不是基本类型值，如果直接=也只是复制了一个指针，如上面的代码一样会互相影响。所以复制操作不能简单的=。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//es5写法</span><br><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[0] = 2;//修改a2并不改变a1</span><br><span class="line">a1 // [1, 2]</span><br><span class="line">//es6写法</span><br><span class="line">const a1 = [1, 2];</span><br><span class="line">// 写法一</span><br><span class="line">const a2 = [...a1];</span><br><span class="line">// 写法二</span><br><span class="line">const [...a2] = a1;</span><br><span class="line"></span><br><span class="line">合并</span><br><span class="line">let arr1 = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">let arr2 = [&apos;c&apos;];</span><br><span class="line">let arr3 = [&apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// ES5的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br><span class="line"></span><br><span class="line">// ES6的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>splice</p>
<p>slice()的返回值是一个数组。接受三个参数。第一个为起始位置。第二个为删除的项数，第三个为插入的项。一个方法就可以实现可以实现增删改的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; </span><br><span class="line">let removed = colors.splice(0,1);                // 删除第一项 </span><br><span class="line">alert(colors);     // green,blue </span><br><span class="line">alert(removed);    // red，返回的数组中只包含一项 </span><br><span class="line"> </span><br><span class="line">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);   // 从位置 1 开始插入两项 </span><br><span class="line">alert(colors);     // green,yellow,orange,blue </span><br><span class="line">alert(removed);    // 返回的是一个空数组 </span><br><span class="line"> </span><br><span class="line">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);      // 插入两项，删除一项 </span><br><span class="line">alert(colors);     // green,red,purple,orange,blue </span><br><span class="line">alert(removed);    // yellow，返回的数组中只包含一项</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="7">
<li><p>转换</p>
<p>Array.from()用于将两类对象转化为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<p>Array.of()用于将一组值转化为数组</p>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设设置一个数组长度为1，值为2.</span><br><span class="line">Array(2)的结果是一个长度为2的空数组。</span><br><span class="line">Array.of()则可以按目的显示。</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br><span class="line"></span><br><span class="line">Array.of(7);       // [7] </span><br><span class="line">Array.of(1, 2, 3); // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">Array(7);          // [ , , , , , , ]</span><br><span class="line">Array(1, 2, 3);    // [1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>   join() 方法将一个数组（或一个<a href="https://developer.mozilla.org/zh-CN//docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects" target="_blank" rel="noopener">类数组对象</a>）的所有元素连接成一个字符串并返回这个字符串。</p>
<ol start="8">
<li><p>位置</p>
<p>indexOf()和 lastIndexOf()。这两个方法都接收<br>两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位<br>置 0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。 这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回1。</p>
<p>es6新增了find()返回值和findIndex()返回索引，都是接收一个测试函数作为第一个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">alert(numbers.indexOf(4));        //3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1, 4, -5, 10].find((n) =&gt; n &lt; 0)</span><br><span class="line">// -5</span><br><span class="line">function f(v)&#123;</span><br><span class="line">  return v &gt; this.age;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;name: &apos;John&apos;, age: 20&#125;;</span><br><span class="line">[10, 12, 26, 15].find(f, person);    // 26</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="9">
<li><p>迭代</p>
<p><strong>对数组进行操作</strong> 还是非常重要的。</p>
<p>ECMAScript 5为数组定义了 5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和<br>（可选的）运行该函数的作用域对象——影响 this 的值。</p>
</li>
</ol>
<p>    every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。<br>    filter()：对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。<br>    forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。<br>    map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>    some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">var filterResult = numbers.filter(function(item, index, array)&#123; </span><br><span class="line">    return (item &gt; 2); </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">alert(filterResult);  //[3,4,5,4,3] </span><br><span class="line">var numbers = [1,2,3,4,5,4,3,2,1]; </span><br><span class="line"> </span><br><span class="line">var mapResult = numbers.map(function(item, index, array)&#123; </span><br><span class="line">    return item * 2; </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">alert(mapResult);  //[2,4,6,8,10,8,6,4,2]</span><br></pre></td></tr></table></figure>
<ol start="10">
<li><p>归并</p>
<p>reduce()和 reduceRight()。这两个方法都会迭<br>代数组的所有项，然后构建一个最终返回的值。可以做累加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var values = [1,2,3,4,5]; </span><br><span class="line">var sum = values.reduce(function(prev, cur, index, array)&#123; </span><br><span class="line">    return prev + cur;  </span><br><span class="line">&#125;); </span><br><span class="line">alert(sum); //15</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="11">
<li><p>fill</p>
<p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line">第二个和第三个参数用于指定填充的起始位置和结束位置</span><br><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</span><br><span class="line">// [&apos;a&apos;, 7, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法也是es6新增，知乎有个问题</p>
<p>JavaScript 怎么快速声明一个数组，长度为 100，元素全是 0？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(100), i=arr.length;</span><br><span class="line">while(i--)&#123;arr[i] = 0;&#125;</span><br><span class="line">或者</span><br><span class="line">Array.apply(null,Array(100)).map(function(item, i) &#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在es6里就只需要很短的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(100).fill(0)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>includes</p>
<p>返回一个布尔值，表示某个数组是否包含给定的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // true</span><br><span class="line">[1, 2, 3].includes(4)     // false</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>更多具体的方法和参数，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">点这里</a>。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>字符串有两个特点：一·类似数组、二·不可变。</p>
<p>也就是说没办法原地修改内容的。</p>
<p>这里有两个方法，split讲一个string对象分隔成字符串数组，join将一个数组所有元素连接成字符串并返回这个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a =&apos;foo&apos;</span><br><span class="line">let c = a</span><br><span class="line">        .split(&apos;&apos;)</span><br><span class="line">        .reverse()</span><br><span class="line">        .join(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">console.log(c)//oof</span><br></pre></td></tr></table></figure>
<p>借用数组的反转来反转字符串。</p>
<p>模板字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function authorize(user, action) &#123;</span><br><span class="line">  if (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    throw new Error(</span><br><span class="line">      // 传统写法为</span><br><span class="line">      // &apos;User &apos;</span><br><span class="line">      // + user.name</span><br><span class="line">      // + &apos; is not authorized to do &apos;</span><br><span class="line">      // + action</span><br><span class="line">      // + &apos;.&apos;</span><br><span class="line">      `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多api不赘述，看文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">点击这里</a>.<a href="http://es6.ruanyifeng.com/#docs/string" target="_blank" rel="noopener">es6新增点这里</a></p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>并没有分离出整数类型，1和1.0相同。就像java里的<strong>double</strong></p>
<p>有一个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0.1 + 0.2 === 0.3; // false</span><br><span class="line">0.30000000000000004</span><br><span class="line">在es6中新增了Number.EPSILON表示容差</span><br><span class="line">function numbersCloseEnoughToEqual(n1,n2) &#123;</span><br><span class="line">	return Math.abs( n1 - n2 ) &lt; Number.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 0.1 + 0.2;</span><br><span class="line">var b = 0.3;</span><br><span class="line"></span><br><span class="line">numbersCloseEnoughToEqual( a, b );					// true</span><br><span class="line">numbersCloseEnoughToEqual( 0.0000001, 0.0000002 );	// false</span><br></pre></td></tr></table></figure>
<p>二进制浮点数的原因。</p>
<p>一些方法就不抄了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt" target="_blank" rel="noopener">点这里</a><a href="http://es6.ruanyifeng.com/#docs/number" target="_blank" rel="noopener">es6新增点这里</a></p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>如果操作本来要返回数值但是未返回数值的情况下，js中并不会抛出错误而是返回NaN。NaN不等于自身</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>对于<code>undefined</code>类型来说，有且仅有一个值：<code>undefined</code>。对于<code>null</code>类型来说，有且仅有一个值：<code>null</code>。所以对它们而言，这些文字既是它们的类型也是它们的值。</p>
<p>undefined翻译一下就是未定义。声明了一个变量但是没有初始化的时候，这个变量的值就是undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var message; </span><br><span class="line">alert(message == undefined); //true</span><br></pre></td></tr></table></figure>
<p>null值表示一个空对象指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var car = null; </span><br><span class="line">alert(typeof car);     // &quot;object&quot; </span><br><span class="line"> </span><br><span class="line">if (car != null)&#123; </span><br><span class="line">    // 对 car 对象执行某些操作 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会返回一个对象，前面说是一个bug。但就算是个bug也是有来由的。</p>
<blockquote>
<p>无论在什么情况下<br>都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，<br>只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以<br>体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。</p>
</blockquote>
<p>null本来就是用于对象。bug也就bug了。</p>
<p>还有一点undefined是一个标识符。但是别用。所有不赘述。</p>
<p>Boolean</p>
<p>也就是true和false。区分大小写，可以用Boolean转换其他值为对应布尔值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var message = &quot;Hello world!&quot;; </span><br><span class="line">var messageAsBoolean = Boolean(message); </span><br><span class="line"> 跑一下</span><br><span class="line">  console.log(messageAsBoolean);</span><br><span class="line">//true</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转化为true</th>
<th>false</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>‘’(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非零数值</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>不适用</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<p>上表就是一些数据类型转化为布尔值的规则。还有一些其他问题在下一节类型转化讨论。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>在js中 三种基本值<code>string</code>，<code>number</code>，或<code>boolean</code>可以发生类型转换 。可以分为隐含强制转换和明确强制转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = 42;</span><br><span class="line"></span><br><span class="line">var b = a + &quot;&quot;;			// 隐含强制转换</span><br><span class="line"></span><br><span class="line">var c = String( a );	// 明确强制转换</span><br><span class="line">跑一下</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(c);</span><br><span class="line">// 结果42 42</span><br></pre></td></tr></table></figure>
<h4 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h4><p>在布尔值一节有个表格，总结转换规则。现在把转换规则再总结</p>
<ul>
<li><p><code>undefined</code></p>
</li>
<li><p><code>null</code></p>
</li>
<li><p><code>false</code></p>
</li>
<li><p><code>+0</code>, <code>-0</code>, and <code>NaN</code></p>
</li>
<li><p><code>&quot;&quot;</code></p>
</li>
</ul>
<p>除去可以变为false的被称为falsy，其他全部变为true被称为truthy。</p>
<p><strong>如果一个值不在falsy列表中，它就是truthy</strong>。</p>
<p>这样就有一些代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if （function foo）&#123;</span><br><span class="line">	do something</span><br><span class="line">&#125;</span><br><span class="line">隐性的做了逻辑判断</span><br></pre></td></tr></table></figure>
<p>一些更复杂的细碎的例子<a href="https://github.com/JoeHetfield/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch4.md" target="_blank" rel="noopener">点这里</a></p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>js中出了基本值外，其他所有值都是对象。</p>
<p>对象是属性的容器，属性名总是字符串。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object(); </span><br><span class="line">person.name = &quot;Nicholas&quot;; </span><br><span class="line">person.age = 29;</span><br></pre></td></tr></table></figure>
<p>对象字面量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123; </span><br><span class="line">    name : &quot;Nicholas&quot;, </span><br><span class="line">    age : 29 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="es6中对象的扩展"><a href="#es6中对象的扩展" class="headerlink" title="es6中对象的扩展"></a>es6中对象的扩展</h2><p>一些对象的基本知识不赘述。这里只总结Object在es6中的扩展</p>
<ol>
<li><p>简洁表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">属性和方法简写</span><br><span class="line">允许直接写入变量和函数，作为对象的属性和方法。方法也可以省个function。</span><br><span class="line">let birth = &apos;2000/01/01&apos;;</span><br><span class="line"></span><br><span class="line">const Person = &#123;</span><br><span class="line"></span><br><span class="line">  name: &apos;张三&apos;,</span><br><span class="line"></span><br><span class="line">  //等同于birth: birth</span><br><span class="line">  birth,</span><br><span class="line"></span><br><span class="line">  // 等同于hello: function ()...</span><br><span class="line">  hello() &#123; console.log(&apos;我的名字是&apos;, this.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="2">
<li><p>属性名表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用对象字面量定义对象时，可以把表达式作为对象的属性名</span><br><span class="line">let propKey = &apos;foo&apos;;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [propKey]: true,</span><br><span class="line">  [&apos;a&apos; + &apos;bc&apos;]: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="3">
<li><p>方法的name属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">函数有name属性，对象的方法是函数所以也有name属性。</span><br><span class="line">const person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(&apos;hello!&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   // &quot;sayName&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="4">
<li><p>Object.is</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0</span><br><span class="line">它用来比较两个值是否严格相等</span><br><span class="line">+0 === -0 //true</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="5">
<li><p>Object.assign</p>
<p>用于对象的合并。讲原对象的所有可枚举属性复制到目标对象，注意：浅拷贝·同名属性替换·取值函数会把值复制过去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line">const source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">const source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="6">
<li><p>属性的可枚举和遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。</span><br><span class="line">let obj = &#123; foo: 123 &#125;</span><br><span class="line">let a = Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</span><br><span class="line">console.log(a);</span><br><span class="line">//configurable: true</span><br><span class="line">enumerable: true</span><br><span class="line">value: 123</span><br><span class="line">writable: true</span><br><span class="line"></span><br><span class="line">其中enumerable属性就是可枚举型</span><br></pre></td></tr></table></figure>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
</li>
<li><p>Object.getOwnPropertyDescriptor</p>
<p>一些高级用法，没用过就不复制粘贴了。以后用过再写。</p>
</li>
<li><p>[[Prototype]]的新增方法</p>
<p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let proto = &#123;&#125;;</span><br><span class="line">let obj = &#123; x: 10 &#125;;</span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = 20;</span><br><span class="line">proto.z = 40;</span><br><span class="line"></span><br><span class="line">obj.x // 10</span><br><span class="line">obj.y // 20</span><br><span class="line">obj.z // 40</span><br><span class="line">将proto对象设为了obj对象的原型。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf用于读取一个对象的原型对象</span><br></pre></td></tr></table></figure>
</li>
<li><p>super关键字</p>
<p>super指向当前对象的原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const proto = &#123;</span><br><span class="line">  foo: &apos;hello&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  find() &#123;</span><br><span class="line">    return super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() // &quot;hello&quot;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol start="10">
<li><p>Object.create</p>
<p>该方法会使用指定的原型对象及其属性去创建一个新的对象。该方法用于模仿继承。在原型篇详细些。</p>
</li>
</ol>
<h2 id="Date类型和RegExp类型"><a href="#Date类型和RegExp类型" class="headerlink" title="Date类型和RegExp类型"></a>Date类型和RegExp类型</h2><p>全是一些方法，写了也是复制粘贴一大串。</p>
<p>没什么特殊的地方<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" rel="noopener">点这里看</a></p>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>Symbol是一种新机制可以保证每个属性的名字独一无二。</p>
<p>Symbol值通过Symbol函数生成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line"></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure>
<p>用作属性名</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p>如果想实现应用同样的Symbol值，可以使用Symbol.for(‘字符串值’),返回一个宜家登记的Symbol值。</p>
<h2 id="Set和Map"><a href="#Set和Map" class="headerlink" title="Set和Map"></a>Set和Map</h2><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>简单的说set类似于数组，但是成员的值都是唯一的，没有重复。<code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...<span class="keyword">set</span>]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br><span class="line"></span><br><span class="line">// 例三</span><br><span class="line">const <span class="keyword">set</span> = new Set(document.querySelectorAll('div'));</span><br><span class="line"><span class="keyword">set</span>.size // 56</span><br><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br><span class="line">[...new Set('ababbc')].join('')</span><br><span class="line">// "abc"</span><br></pre></td></tr></table></figure>
<p>操作方法暂时不写，确实没怎么用过。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
<p>使用方法暂时不写，确实没怎么用过</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>js中的类型松散。基本类型不像其他语言分的那么细。而且还有隐含的强制转换。用的时候即方便又要倍加小心。引用类型就是Object对象的子类型。有个固有的属性和方法。而这些属性和方法是建立在原型上的。有关原型，拷贝，继承等等都不在这篇博客说了。本篇博客主要总结了一些内建类型的原生方法。以后随时增删。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/22/重温JS(1)-类型/" data-id="cjtjs8kbj0009fguntt7wnd6z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/22/this指向和闭包/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          this指向与闭包
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/22/sa/">sa</a>
          </li>
        
          <li>
            <a href="/2019/03/22/ssss/">ssss</a>
          </li>
        
          <li>
            <a href="/2019/03/22/ss/">ss</a>
          </li>
        
          <li>
            <a href="/2019/03/20/写博客/">写博客</a>
          </li>
        
          <li>
            <a href="/2019/02/22/原型与原型链/">原型链与继承</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 李向<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>